Script started on 2018-05-02 11:07:12-0500
bash-4.4$ [Kbash-4.4$ whoami | name -w
No arguments, operating as filter
Userid    Name                          Home Dir
jbujula   Jayanth Reddy Bujula          /home/jbujula 
Found 1 matches
bash-4.4$ ls -ltr
total 460
-rw-r--r-- 1 jbujula jbujula   1353 Feb 26 22:17 Hextoany.java
-rw-r--r-- 1 jbujula jbujula   1301 Feb 27 10:50 report
-rw-r--r-- 1 jbujula jbujula    348 Apr  2 23:53 PMT.java
-rw-r--r-- 1 jbujula jbujula   2807 Apr 29 21:13 ERROR_HANDLER.java
-rw-r--r-- 1 jbujula jbujula    860 Apr 30 01:55 DISK.java
-rw-r--r-- 1 jbujula jbujula   2528 May  1 13:29 MEMORY.java
-rw-r--r-- 1 jbujula jbujula   8893 May  1 13:32 FAULT_HANDLER.java
-rw-r--r-- 1 jbujula jbujula  32148 May  1 14:11 CPU.java
-rw-r--r-- 1 jbujula jbujula   3095 May  1 15:34 PCB.java
-rw-r--r-- 1 jbujula jbujula   3047 May  1 16:28 LOADER.java
-rw-r--r-- 1 jbujula jbujula   2623 May  1 16:33 report.txt
-rw-r--r-- 1 jbujula jbujula  24269 May  2 10:43 input_phase2
-rw-r--r-- 1 jbujula jbujula  34166 May  2 10:44 SYSTEM.java
-rw------- 1 jbujula jbujula   9232 May  2 10:53 output
-rw------- 1 jbujula jbujula 292914 May  2 10:55 Execution_profile.txt
-rw-r--r-- 1 jbujula jbujula  16936 May  2 11:04 OUTPUTSPOOLING.java
-rw------- 1 jbujula jbujula      0 May  2 11:07 typescript
bash-4.4$ javac *.java
bash-4.4$ ls -ltr
total 540
-rw-r--r-- 1 jbujula jbujula   1353 Feb 26 22:17 Hextoany.java
-rw-r--r-- 1 jbujula jbujula   1301 Feb 27 10:50 report
-rw-r--r-- 1 jbujula jbujula    348 Apr  2 23:53 PMT.java
-rw-r--r-- 1 jbujula jbujula   2807 Apr 29 21:13 ERROR_HANDLER.java
-rw-r--r-- 1 jbujula jbujula    860 Apr 30 01:55 DISK.java
-rw-r--r-- 1 jbujula jbujula   2528 May  1 13:29 MEMORY.java
-rw-r--r-- 1 jbujula jbujula   8893 May  1 13:32 FAULT_HANDLER.java
-rw-r--r-- 1 jbujula jbujula  32148 May  1 14:11 CPU.java
-rw-r--r-- 1 jbujula jbujula   3095 May  1 15:34 PCB.java
-rw-r--r-- 1 jbujula jbujula   3047 May  1 16:28 LOADER.java
-rw-r--r-- 1 jbujula jbujula   2623 May  1 16:33 report.txt
-rw-r--r-- 1 jbujula jbujula  24269 May  2 10:43 input_phase2
-rw-r--r-- 1 jbujula jbujula  34166 May  2 10:44 SYSTEM.java
-rw------- 1 jbujula jbujula   9232 May  2 10:53 output
-rw------- 1 jbujula jbujula 292914 May  2 10:55 Execution_profile.txt
-rw-r--r-- 1 jbujula jbujula  16936 May  2 11:04 OUTPUTSPOOLING.java
-rw------- 1 jbujula jbujula      0 May  2 11:07 typescript
-rw------- 1 jbujula jbujula  12815 May  2 11:07 CPU.class
-rw------- 1 jbujula jbujula   3811 May  2 11:07 PCB.class
-rw------- 1 jbujula jbujula   1648 May  2 11:07 ERROR_HANDLER.class
-rw------- 1 jbujula jbujula    427 May  2 11:07 PMT.class
-rw------- 1 jbujula jbujula    744 May  2 11:07 DISK.class
-rw------- 1 jbujula jbujula   4105 May  2 11:07 FAULT_HANDLER.class
-rw------- 1 jbujula jbujula   1675 May  2 11:07 Hextoany.class
-rw------- 1 jbujula jbujula   3066 May  2 11:07 LOADER.class
-rw------- 1 jbujula jbujula   1617 May  2 11:07 MEMORY.class
-rw------- 1 jbujula jbujula  11025 May  2 11:07 OUTPUTSPOOLING.class
-rw------- 1 jbujula jbujula  15395 May  2 11:07 SYSTEM.class
bash-4.4$ pr -n *.java


2018-05-01 14:11                     CPU.java                     Page 1


    1	/**
    2	 * After LOADER completes its execution the SYSTEM transfers its control to the CPU.
    3	 * CPU gets two parameters, objpc and a trace_flag.
    4	 * objpc provides CPU with the start address from where the execution should start.
    5	 * And if the trace_flag is enabled the CPU prints objpc,br,ea,(ea),objtos,objstack[objtos] for every instruction it executes.
    6	 */
    7	import java.util.ArrayList;
    8	import java.util.ListIterator;
    9	
   10	
   11	class CPU {
   12	
   13	    @SuppressWarnings("unchecked")
   14	    public static PCB cpu_fun(String x, int y, PCB obj) throws ERROR_HANDLER {
   15	        String opcode, operation;
   16	        obj.cpushot++;
   17	        //objpc value is calculated by adding br to it.
   18	        obj.pc = Integer.parseInt(x);
   19	
   20	        while (true) {
   21	
   22	            obj.pc_old = (obj.pc);
   23	            //If clock exceeds 10000 it throws a warning and the exception is handled by the EXCEPTION_HANDLER
   24	            //  if (SYSTEM.clock > 10000) {
   25	            //      throw new ERROR_HANDLER(11);
   26	            //  }
   27	            //The below condition checks the overflow and underflow condition of top of objstack and throws a respective
   28	            // exception if condition file.
   29	            if (obj.tos < 0) {
   30	                throw new ERROR_HANDLER(12);
   31	            } else if (obj.tos > 7) {
   32	                throw new ERROR_HANDLER(13);
   33	            }
   34	            ArrayList al1 = new ArrayList();
   35	            opcode = "";
   36	            if(SYSTEM.snapshot>200){
   37	                SYSTEM.snapshot=0;
   38	                OUTPUTSPOOLING.snapshot_fun(obj);
   39	
   40	            }
   41	            if(obj.run_time>10000){
   42	                SYSTEM.infinite_id.add(SYSTEM.job_id.get(obj));
   43	                throw new ERROR_HANDLER(11);
   44	
   45	            }
   46	            if (obj.execution_time_in_cpu >= 20) {
   47	                obj.execution_flag = 1;
   48	                break;
   49	            }
   50	            SYSTEM.clock++;
   51	            SYSTEM.snapshot++;
   52	            // Each Instruction is read from the MEMORY using objpc.
   53	            obj.ir = MEMORY.Memory_function("read", Integer.toBinaryString(obj.pc), "0", obj);
   54	
   55	            if (obj.ir.equals("pagefault")) {
   56	







2018-05-01 14:11                     CPU.java                     Page 2


   57	                break;
   58	            }
   59	            // An arraylist al1 is created to store respective variable values to print
   60	            if (Integer.parseInt(obj.trace_flag) == 1) {
   61	                al1.add(Integer.toHexString(obj.pc));
   62	                al1.add((obj.br));
   63	                al1.add(Hextoany.Binarytohex(obj.ir));
   64	                al1.add(Integer.toHexString(obj.tos));
   65	                if (obj.stack[obj.tos] == null || obj.stack[obj.tos].equals("")) {
   66	                    al1.add(Hextoany.Binarytohex("0"));
   67	                } else {
   68	                    al1.add(Hextoany.Binarytohex(obj.stack[obj.tos]));
   69	                }
   70	            }
   71	            obj.pcc = obj.pc = obj.pc + 1;
   72	            // Checks whether an instruction is zero
   73	            if (obj.ir.charAt(0) == '0') {
   74	
   75	                if (Integer.parseInt(obj.trace_flag) == 1) {
   76	                    al1.add(Integer.toHexString(obj.ea));
   77	                    al1.add(0);
   78	                }
   79	                // The SYSTEM clock is incremented for each fetch of an instruction
   80	                obj.run_time++;
   81	                SYSTEM.clock++;
   82	                SYSTEM.snapshot++;
   83	                obj.execution_time_in_cpu++;
   84	                obj.instriction_type = 1;
   85	                opcode = obj.ir.substring(3, obj.ir.length() / 2);
   86	                operation = zeroaddress(opcode, obj);
   87	                if (obj.flag_segmentfault_input == 1 || obj.flag_segmentfault_output == 1 || obj.flag_pagefault == 1) {
   88	                    break;
   89	                }
   90	                // If halt return the control to the SYSTEM
   91	                if (operation.equals("HALT")) {
   92	                    if(obj.trace_flag.equals("1")){
   93	                    ListIterator<String> litr = al1.listIterator();
   94	                    while (litr.hasNext()) {
   95	
   96	                        {
   97	                            obj.pw.print(String.format("%7s", litr.next()));
   98	                        }
   99	
  100	
  101	                    }}
  102	                    obj.exit_flag = 1;
  103	                    if(obj.trace_flag.equals("1")) {
  104	                        obj.pw.close();
  105	                    }
  106	                    obj.halt_flag=1;
  107	                    OUTPUTSPOOLING.output(obj);
  108	
  109	                    break;
  110	                }
  111	                // Increment the clock by 15 if an I/O instruction is found.
  112	                if (operation.equals("RD") || operation.equals("WR")) {







2018-05-01 14:11                     CPU.java                     Page 3


  113	                    SYSTEM.clock = SYSTEM.clock + 15;
  114	                    SYSTEM.snapshot=SYSTEM.snapshot+15;
  115	                    obj.execution_time_in_cpu = obj.execution_time_in_cpu + 15;
  116	                    obj.run_time = obj.run_time + 15;
  117	                    obj.clock1 = obj.clock1 + 15;
  118	                }
  119	                opcode = "";
  120	                if (obj.pcc == obj.pc) {
  121	                    obj.run_time++;
  122	                    SYSTEM.clock++;
  123	                    SYSTEM.snapshot++;
  124	                    obj.execution_time_in_cpu++;
  125	                    opcode = obj.ir.substring(11, obj.ir.length());
  126	                    operation = zeroaddress(opcode, obj);
  127	                    if (obj.flag_segmentfault_input == 1 || obj.flag_segmentfault_output == 1 || obj.flag_pagefault ==
  128	                            1) {
  129	                        break;
  130	                    }
  131	                    if (operation.equals("HALT")) {
  132	                        obj.halt_flag=1;
  133	                        if(obj.trace_flag.equals("1")){
  134	                        ListIterator<String> litr = al1.listIterator();
  135	                        while (litr.hasNext()) {
  136	
  137	                            {
  138	                                obj.pw.print(String.format("%7s", litr.next()));
  139	                            }
  140	
  141	
  142	                        }}
  143	                        obj.exit_flag = 1;
  144	                        if(obj.trace_flag.equals("1")){
  145	                        obj.pw.close();}
  146	                        OUTPUTSPOOLING.output(obj);
  147	
  148	                        break;
  149	                    }
  150	                    if (operation.equals("RD") || operation.equals("WR")) {
  151	                        SYSTEM.clock = SYSTEM.clock + 15;
  152	                        SYSTEM.snapshot=SYSTEM.snapshot+15;
  153	                        obj.execution_time_in_cpu = obj.execution_time_in_cpu + 15;
  154	                        obj.run_time = obj.run_time + 15;
  155	                        obj.clock1 = obj.clock1 + 15;
  156	                    }
  157	                    // PRINT TO FILE
  158	                }
  159	                if (Integer.parseInt(obj.trace_flag) == 1) {
  160	                    al1.add(Integer.toHexString(obj.tos));
  161	                    if (obj.stack[obj.tos] == null || obj.stack[obj.tos].equals("")) {
  162	                        al1.add(Hextoany.Binarytohex("0"));
  163	                    } else {
  164	                        al1.add(Hextoany.Binarytohex(obj.stack[obj.tos]));
  165	                    }
  166	                    al1.add(Integer.toHexString(obj.ea));
  167	                    if (SYSTEM.memory_variable[obj.ea] == null || SYSTEM.memory_variable[obj.ea].equals("") || SYSTEM.memory_variable[obj.ea].equals(" ")) {
  168	                        al1.add(Hextoany.Binarytohex("0"));







2018-05-01 14:11                     CPU.java                     Page 4


  169	                    } else {
  170	                        al1.add(Hextoany.Binarytohex(SYSTEM.memory_variable[obj.ea]));
  171	                    }
  172	                }
  173	
  174	            }
  175	            // Executes else condition if it is one address Instruction.
  176	            else {
  177	                if (Integer.parseInt(obj.trace_flag) == 1) {
  178	                    al1.add(Integer.toHexString(obj.ea));
  179	                    if (SYSTEM.memory_variable[obj.ea] == null || SYSTEM.memory_variable[obj.ea].equals("")|| SYSTEM.memory_variable[obj.ea].equals(" ")) {
  180	                        al1.add(Hextoany.Binarytohex("0"));
  181	                    } else {
  182	                        al1.add(Hextoany.Binarytohex(SYSTEM.memory_variable[obj.ea]));
  183	                    }
  184	
  185	                }
  186	                opcode = obj.ir.substring(1, 6);
  187	                obj.instriction_type = 2;
  188	                operation = oneaddress(opcode, obj);
  189	                if (obj.flag_pagefault == 1) {
  190	                    break;
  191	                }
  192	                if (Integer.parseInt(obj.trace_flag) == 1) {
  193	                    al1.add(Integer.toHexString(obj.tos));
  194	                    al1.add((Hextoany.Binarytohex(obj.stack[obj.tos])));
  195	                    al1.add(Integer.toHexString(obj.ea));
  196	                    if (SYSTEM.memory_variable[obj.ea] == null || SYSTEM.memory_variable[obj.ea].equals("")|| SYSTEM.memory_variable[obj.ea].equals(" ")) {
  197	                        al1.add(Hextoany.Binarytohex("0"));
  198	                    } else {
  199	                        al1.add(Hextoany.Binarytohex(SYSTEM.memory_variable[obj.ea]));
  200	                    }
  201	
  202	                }
  203	
  204	
  205	                if (operation.equals("HALT")) {
  206	                    obj.halt_flag=1;
  207	                    if(obj.trace_flag.equals("1")) {
  208	                        obj.pw.close();
  209	                    }
  210	                    OUTPUTSPOOLING.output(obj);
  211	
  212	                    break;
  213	                }
  214	                if (operation.equals("RD") || operation.equals("WR")) {
  215	                    SYSTEM.clock = SYSTEM.clock + 15;
  216	                    SYSTEM.snapshot=SYSTEM.snapshot+15;
  217	                    obj.execution_time_in_cpu = obj.execution_time_in_cpu + 15;
  218	                    obj.run_time = obj.run_time + 15;
  219	                    obj.clock1 = obj.clock1 + 15;
  220	                } else {
  221	                    SYSTEM.clock = SYSTEM.clock + 4;
  222	                    SYSTEM.snapshot=SYSTEM.snapshot+4;
  223	                    obj.execution_time_in_cpu = obj.execution_time_in_cpu + 4;
  224	                    obj.run_time = obj.run_time + 4;







2018-05-01 14:11                     CPU.java                     Page 5


  225	                }
  226	            }
  227	
  228	            if(obj.trace_flag.equals("1")){
  229	            ListIterator<String> litr = al1.listIterator();
  230	            while (litr.hasNext()) {
  231	                obj.pw.print(String.format("%7s", litr.next()));
  232	
  233	            }
  234	            obj.pw.println();
  235	        }}
  236	        return obj;
  237	    }
  238	
  239	    // Function for executing a Zero address instruction.
  240	    public static String zeroaddress(String ins, PCB obj) throws ERROR_HANDLER {
  241	        String d = "";
  242	        int i;
  243	        switch (ins) {
  244	            case "00000": {
  245	                return "NOP";
  246	
  247	            }
  248	            case "00001": {
  249	                String len;
  250	                //performs a binary 'OR' operation on top two objstack elements
  251	                len = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos]) | Hextoany.bintodecimal(obj.stack[obj.tos - 1]));
  252	                d = cut(d);
  253	                obj.stack[obj.tos - 1] = len;
  254	                obj.tos = obj.tos - 1;
  255	                return "OR";
  256	            }
  257	            case "00010": {
  258	                //performs a binary 'AND' operation on top two objstack elements
  259	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos]) & Hextoany.bintodecimal(obj.stack[obj.tos - 1]));
  260	                d = cut(d);
  261	                obj.stack[obj.tos - 1] = d;
  262	                obj.tos = obj.tos - 1;
  263	                return "AND";
  264	            }
  265	            case "00011": {
  266	                //performs a binary 'NOT' operation on top two objstack elements
  267	                String s = Integer.toBinaryString(~Hextoany.bintodecimal((obj.stack[obj.tos])));
  268	                StringBuffer sb = new StringBuffer(s);
  269	                obj.stack[obj.tos] = sb.delete(0, 16).toString();
  270	
  271	                return "NOT";
  272	            }
  273	            case "00100": {
  274	                //performs a binary 'XOR' operation on top two objstack elements
  275	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos]) ^ Hextoany.bintodecimal(obj.stack[obj.tos - 1]));
  276	                d = cut(d);
  277	                obj.stack[obj.tos - 1] = d;
  278	                obj.tos = obj.tos - 1;
  279	                return "XOR";
  280	            }







2018-05-01 14:11                     CPU.java                     Page 6


  281	            case "00101": {
  282	                //neg function is called which checks whether the objtos contains a negative element.
  283	                i = neg(obj);
  284	                //performs a binary 'ADD' operation on top two objstack elements
  285	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos - 1]) + i);
  286	                d = cut(d);
  287	                obj.stack[obj.tos - 1] = d;
  288	                obj.tos = obj.tos - 1;
  289	                return "ADD";
  290	            }
  291	            case "00110": {
  292	                i = neg(obj);
  293	                //performs a binary 'SUB' operation on top two objstack elements
  294	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos - 1]) - i);
  295	                d = cut(d);
  296	                obj.stack[obj.tos - 1] = d;
  297	                obj.tos = obj.tos - 1;
  298	                return "SUB";
  299	            }
  300	            case "00111": {
  301	                i = neg(obj);
  302	                //performs a binary 'MUL' operation on top two objstack elements
  303	                d = Integer.toBinaryString(i * Hextoany.bintodecimal(obj.stack[obj.tos - 1]));
  304	                d = cut(d);
  305	                obj.stack[obj.tos - 1] = d;
  306	                obj.tos = obj.tos - 1;
  307	                return "MUL";
  308	            }
  309	            case "01000": {
  310	                i = neg(obj);
  311	                //performs a binary 'DIV' operation on top two objstack elements
  312	                try {
  313	                    d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos - 1]) / i);
  314	                }catch (Exception e){ throw  new ERROR_HANDLER(16);}
  315	                d = cut(d);
  316	                obj.stack[obj.tos - 1] = d;
  317	                obj.tos = obj.tos - 1;
  318	                return "DIV";
  319	            }
  320	            case "01001": {
  321	                i = neg(obj);
  322	                //performs a binary 'MOD' operation on top two objstack elements
  323	             try{
  324	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos - 1]) % i);
  325	            }catch (Exception e){
  326	
  327	                throw new ERROR_HANDLER(13);
  328	            }
  329	                d = cut(d);
  330	                obj.stack[obj.tos - 1] = d;
  331	                obj.tos = obj.tos - 1;
  332	                return "MOD";
  333	            }
  334	            case "01010": {
  335	                //performs left shift operation on objtos.
  336	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos]) << 1);







2018-05-01 14:11                     CPU.java                     Page 7


  337	                d = cut(d);
  338	                obj.stack[obj.tos] = d;
  339	                return "SL";
  340	            }
  341	            case "01011": {
  342	                //performs right shift operation on objtos.
  343	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos]) >> 1);
  344	                d = cut(d);
  345	                obj.stack[obj.tos] = d;
  346	                return "SR";
  347	            }
  348	            case "01100": {
  349	                i = neg(obj);
  350	                // compares whether objstack[objtos-1] is greater than objstack[objtos]
  351	                boolean len = (Hextoany.bintodecimal(obj.stack[obj.tos - 1]) > i);
  352	                if (len) {
  353	                    obj.stack[obj.tos + 1] = "0000000000000001";
  354	                } else {
  355	                    obj.stack[obj.tos + 1] = "0000000000000000";
  356	                }
  357	                obj.tos = obj.tos + 1;
  358	                return "CPG";
  359	            }
  360	            case "01101": {
  361	                i = neg(obj);
  362	                // compares whether objstack[objtos-1] is less than objstack[objtos]
  363	                boolean len = (Hextoany.bintodecimal(obj.stack[obj.tos - 1]) < i);
  364	                if (len) {
  365	                    obj.stack[obj.tos + 1] = "0000000000000001";
  366	                } else {
  367	                    obj.stack[obj.tos + 1] = "0000000000000000";
  368	                }
  369	                obj.tos = obj.tos + 1;
  370	                return "CPL";
  371	            }
  372	            case "01110": {
  373	                i = neg(obj);
  374	                // compares whether objstack[objtos-1] is equal than objstack[objtos]
  375	                boolean len = (Hextoany.bintodecimal(obj.stack[obj.tos - 1]) == i);
  376	                if (len) {
  377	                    obj.stack[obj.tos + 1] = "0000000000000001";
  378	                } else {
  379	                    obj.stack[obj.tos + 1] = "0000000000000000";
  380	                }
  381	                obj.tos = obj.tos + 1;
  382	                return "CPE";
  383	            }
  384	            case "01111": {
  385	                return "BR";
  386	            }
  387	            case "10000": {
  388	                return "BRT";
  389	            }
  390	            case "10001": {
  391	                return "BRF";
  392	            }







2018-05-01 14:11                     CPU.java                     Page 8


  393	            case "10010": {
  394	
  395	                return "CALL";
  396	            }
  397	            case "10011": {
  398	                obj.ioshot++;
  399	//segment fault handler for first read operation
  400	                if (obj.input_data_segment_pointer == 0) {
  401	
  402	                    obj.flag_segmentfault_input = 1;
  403	
  404	                    return "";
  405	
  406	                } else {
  407	
  408	
  409	                    if (obj.input_data_segment_index + 1 > obj.input_segment_size) {
  410	                        throw new ERROR_HANDLER(21);
  411	                    }
  412	                    int s = (obj.input_data_segment_pointer) * 8 + (obj.input_data_segment_index);
  413	//page fault occurs if the respective page is not in the memory - job releases CPU and control is returned to the SYSTEM
  414	                    d = (MEMORY.Memory_function("read", Integer.toBinaryString(s), "0", obj));
  415	                    //if pagefault occurs job releases CPU and returns the control to the SYSTEM
  416	                    if (d.equals("pagefault")) {
  417	                        return "";
  418	                    }
  419	                    obj.input_data_segment_index++;
  420	
  421	                    obj.stack[++obj.tos] = d;
  422	                    return "RD";
  423	                }
  424	            }
  425	            case "10100": {
  426	                obj.ioshot++;
  427	                //segment fault handler for first write operation - job releases CPU and control is returned to the SYSTEM
  428	                if (obj.output_data_segment_pointer == 0) {
  429	                    obj.flag_segmentfault_output = 1;
  430	
  431	                    return "";
  432	
  433	                } else {
  434	                    if (obj.output_data_segment_index + 1 > obj.output_segment_size) {
  435	                        throw new ERROR_HANDLER(22);
  436	                    }
  437	                    int s = (obj.output_data_segment_pointer) * 8 + (obj.output_data_segment_index);
  438	
  439	                    //if pagefault occurs job releases CPU and returns the control to the SYSTEM
  440	                    String wri = MEMORY.Memory_function("write", Integer.toString(s), obj.stack[obj.tos], obj);
  441	                    if (wri.equals("pagefault")) {
  442	                        return "";
  443	                    }
  444	                    obj.output_data_segment_index++;
  445	                    obj.output.add(obj.stack[obj.tos]);
  446	
  447	
  448	                    obj.tos = obj.tos - 1;







2018-05-01 14:11                     CPU.java                     Page 9


  449	                    obj.disk_fragment_size--;
  450	                    return "WR";
  451	                }
  452	            }
  453	            case "10101": {
  454	                // contents of objstack[objtos] is placed in objpc
  455	                obj.pc = (Hextoany.bintodecimal(obj.stack[obj.tos]));
  456	                obj.tos = obj.tos - 1;
  457	                return "RTN";
  458	            }
  459	            case "10110": {
  460	                return "PUSH";
  461	            }
  462	            case "10111": {
  463	                return "POP";
  464	            }
  465	            case "11000": {
  466	                return "HALT";
  467	            }
  468	            default:
  469	                break;
  470	        }
  471	
  472	        return "";
  473	    }
  474	
  475	    // Function for executing a One address instruction.
  476	    public static String oneaddress(String ins, PCB obj) throws ERROR_HANDLER {
  477	        String d, len1;
  478	        int i;
  479	
  480	        // Condition to evaluate the effective address
  481	        if (obj.ir.charAt(6) == '1') {
  482	            obj.ea = Hextoany.bintodecimal(obj.ir.substring(9, obj.ir.length())) + Hextoany.bintodecimal(obj.stack[obj.tos]) +
  483	                    Integer.parseInt(obj.br);
  484	
  485	        } else {
  486	            obj.ea = Hextoany.bintodecimal(obj.ir.substring(9, obj.ir.length())) + Integer.parseInt(obj.br);
  487	
  488	        }
  489	        switch (ins) {
  490	            case "00000": {
  491	                return "NOP";
  492	            }
  493	            case "00001": {
  494	                // performs "OR" on objstack[objtos] and element present in effective address.
  495	                len1 = index(obj);
  496	                if (len1.equals("pagefault")) {
  497	                    return "";
  498	                }
  499	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos]) | Hextoany.bintodecimal(len1));
  500	                d = cut(d);
  501	                obj.stack[obj.tos] = d;
  502	                return "OR";
  503	            }
  504	            case "00010": {







2018-05-01 14:11                    CPU.java                     Page 10


  505	
  506	                len1 = index(obj);
  507	                if (len1.equals("pagefault")) {
  508	                    return "";
  509	                }
  510	                // performs "AND" on objstack[objtos] and element present in effective address.
  511	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos]) & Hextoany.bintodecimal(len1));
  512	                d = cut(d);
  513	
  514	                obj.stack[obj.tos] = d;
  515	                return "AND";
  516	            }
  517	            case "00011": {
  518	                return "NOT";
  519	            }
  520	            case "00100": {
  521	                len1 = index(obj);
  522	                if (len1.equals("pagefault")) {
  523	                    return "";
  524	                }
  525	                // performs "XOR" on objstack[objtos] and element present in effective address.
  526	                d = Integer.toBinaryString(Hextoany.bintodecimal(obj.stack[obj.tos]) ^ Hextoany.bintodecimal(len1));
  527	                d = cut(d);
  528	                obj.stack[obj.tos] = d;
  529	                return "XOR";
  530	            }
  531	            case "00101": {
  532	                len1 = index(obj);
  533	                if (len1.equals("pagefault")) {
  534	                    return "";
  535	                }
  536	                // performs "ADD" on objstack[objtos] and element present in effective address.
  537	
  538	                if (obj.stack[obj.tos].charAt(0) == '1') {
  539	                    obj.stack1 = reverse(obj.stack[obj.tos]);
  540	                    i = 0 - Hextoany.bintodecimal(obj.stack1);
  541	                } else {
  542	                    i = Hextoany.bintodecimal(obj.stack[obj.tos]);
  543	                }
  544	                d = Integer.toBinaryString(i + Hextoany.bintodecimal(len1));
  545	                d = cut(d);
  546	                obj.stack[obj.tos] = d;
  547	                return "ADD";
  548	            }
  549	            case "00110": {
  550	
  551	                len1 = index(obj);
  552	                if (len1.equals("pagefault")) {
  553	                    return "";
  554	                }
  555	                // performs "SUB" on objstack[objtos] and element present in effective address.
  556	                i = neg(obj);
  557	                d = Integer.toBinaryString(i - Hextoany.bintodecimal(len1));
  558	                d = cut(d);
  559	                obj.stack[obj.tos] = d;
  560	                return "SUB";







2018-05-01 14:11                    CPU.java                     Page 11


  561	            }
  562	            case "00111": {
  563	                // performs "MUL" on objstack[objtos] and element present in effective address.
  564	                len1 = index(obj);
  565	                if (len1.equals("pagefault")) {
  566	                    return "";
  567	                }
  568	                i = neg(obj);
  569	                d = Integer.toBinaryString(i * Hextoany.bintodecimal(len1));
  570	                d = cut(d);
  571	                obj.stack[obj.tos] = d;
  572	                return "MUL";
  573	            }
  574	            case "01000": {
  575	                // performs "DIV" on objstack[objtos] and element present in effective address.
  576	                len1 = index(obj);
  577	                if (len1.equals("pagefault")) {
  578	                    return "";
  579	                }
  580	                i = neg(obj);
  581	                try {
  582	                    d = Integer.toBinaryString(i / Hextoany.bintodecimal(len1));
  583	                }catch (Exception e){
  584	
  585	                    throw new ERROR_HANDLER(13);
  586	                }
  587	                d = cut(d);
  588	                obj.stack[obj.tos] = d;
  589	                return "DIV";
  590	            }
  591	            case "01001": {
  592	                // performs "MOD" on objstack[objtos] and element present in effective address.
  593	                len1 = index(obj);
  594	                if (len1.equals("pagefault")) {
  595	                    return "";
  596	                }
  597	                i = neg(obj);
  598	                try{
  599	                d = Integer.toBinaryString(i % Hextoany.bintodecimal(len1));
  600	            }catch (Exception e){
  601	
  602	                throw new ERROR_HANDLER(13);
  603	            }
  604	                d = cut(d);
  605	                obj.stack[obj.tos] = d;
  606	                return "MOD";
  607	            }
  608	            case "01010": {
  609	
  610	                return "SL";
  611	            }
  612	            case "01011": {
  613	
  614	                return "SR";
  615	            }
  616	            case "01100": {







2018-05-01 14:11                    CPU.java                     Page 12


  617	                len1 = index(obj);
  618	                if (len1.equals("pagefault")) {
  619	                    return "";
  620	                }
  621	                i = neg(obj);
  622	                // compares the objstack[objtos] element with the element present in effective address
  623	                // and places true if objstack[objtos] is greater than (ea)
  624	                boolean len = (i > Hextoany.bintodecimal(len1));
  625	                if (len) {
  626	                    obj.stack[obj.tos + 1] = "0000000000000001";
  627	                } else {
  628	                    obj.stack[obj.tos + 1] = "0000000000000000";
  629	                }
  630	                obj.tos = obj.tos + 1;
  631	                return "CPG";
  632	            }
  633	            case "01101": {
  634	                len1 = index(obj);
  635	                if (len1.equals("pagefault")) {
  636	                    return "";
  637	                }
  638	                i = neg(obj);
  639	                // compares the objstack[objtos] element with the element present in effective address
  640	                // and places true if objstack[objtos] is less than (ea)
  641	                boolean len = (i < Hextoany.bintodecimal(len1));
  642	                if (len) {
  643	                    obj.stack[obj.tos + 1] = "0000000000000001";
  644	                } else {
  645	                    obj.stack[obj.tos + 1] = "0000000000000000";
  646	                }
  647	                obj.tos = obj.tos + 1;
  648	                return "CPL";
  649	            }
  650	            case "01110": {
  651	                len1 = index(obj);
  652	                if (len1.equals("pagefault")) {
  653	                    return "";
  654	                }
  655	                i = neg(obj);
  656	                // compares the objstack[objtos] element with the element present in effective address
  657	                // and places true if objstack[objtos] is equal than (ea)
  658	                boolean len = (i == Hextoany.bintodecimal(len1));
  659	                if (len) {
  660	                    obj.stack[obj.tos + 1] = "0000000000000001";
  661	                } else {
  662	                    obj.stack[obj.tos + 1] = "0000000000000000";
  663	                }
  664	                obj.tos = obj.tos + 1;
  665	                return "CPE";
  666	            }
  667	            case "01111": {
  668	
  669	                obj.pc = obj.ea;
  670	                return "BR";
  671	            }
  672	            case "10000": {







2018-05-01 14:11                    CPU.java                     Page 13


  673	                // brances to effective address of memory if objstack[objtos]is true
  674	                if (obj.stack[obj.tos].equals("0000000000000001")) {
  675	
  676	                    obj.pc = obj.ea;
  677	                }
  678	                obj.tos = obj.tos - 1;
  679	                return "BRT";
  680	            }
  681	            case "10001": {
  682	                // brances to effective address of memory if objstack[objtos]is false
  683	                if (obj.stack[obj.tos].equals("0000000000000000")) {
  684	
  685	                    obj.pc = obj.ea;
  686	                }
  687	                obj.tos = obj.tos - 1;
  688	                return "BRF";
  689	            }
  690	            case "10010": {
  691	
  692	                d = Integer.toBinaryString(obj.pc);
  693	                d = cut(d);
  694	                obj.stack[++obj.tos] = d;
  695	                obj.pc = obj.ea;
  696	                return "CALL";
  697	            }
  698	            case "10011": {
  699	
  700	                return "RD";
  701	            }
  702	            case "10100": {
  703	
  704	                return "WR";
  705	            }
  706	            case "10101": {
  707	
  708	                return "RTN";
  709	            }
  710	            case "10110": {
  711	                // push the element present in effective address to objstack[objtos]
  712	                len1 = index(obj);
  713	                if (len1.equals("pagefault")) {
  714	                    return "";
  715	                }
  716	                try{
  717	                obj.stack[++obj.tos] = len1;
  718	            }catch(Exception e){
  719	                throw new ERROR_HANDLER(13);
  720	
  721	            }
  722	                return "PUSH";
  723	            }
  724	            case "10111": {
  725	
  726	                // pops element in objstack[objtos] to effective address of memory
  727	                if (obj.ir.charAt(6) == '1') {
  728	                    String s = MEMORY.Memory_function("write", Integer.toString(Hextoany.bintodecimal







2018-05-01 14:11                    CPU.java                     Page 14


  729	                            (obj.ir.substring(9, obj.ir.length())) + Hextoany.bintodecimal(obj.stack[obj.tos])), obj.stack[obj.tos], obj);
  730	                    if (s.equals("pagefault")) {
  731	                        return "";
  732	                    }
  733	                } else {
  734	
  735	                    String s = MEMORY.Memory_function("write", Integer.toString(Hextoany.bintodecimal
  736	                            (obj.ir.substring(9, obj.ir.length()))), obj.stack[obj.tos], obj);
  737	                    if (s.equals("pagefault")) {
  738	                        return "";
  739	                    }
  740	                }
  741	                obj.tos = obj.tos - 1;
  742	                return "POP";
  743	            }
  744	            case "11000": {
  745	                System.exit(1);
  746	                return "HLT";
  747	            }
  748	            default:
  749	                break;
  750	        }
  751	
  752	
  753	        return "";
  754	  }
  755	
  756	    // complements an input.txt binary parameter
  757	    private static String reverse(String d) {
  758	
  759	        String e = Integer.toBinaryString(0 - Hextoany.bintodecimal(d));
  760	        if (e.length() < 16) {
  761	            e = Hextoany.pad(e);
  762	        } else if (e.length() > 16) {
  763	            e = trim(e);
  764	        }
  765	        return e;
  766	    }
  767	
  768	    private static String cut(String d) {
  769	        if (d.length() < 16) {
  770	            d = Hextoany.pad(d);
  771	        } else if (d.length() > 16) {
  772	            d = trim(d);
  773	        }
  774	        return d;
  775	    }
  776	
  777	    private static int neg(PCB obj) {
  778	        int i;
  779	        if (obj.stack[obj.tos].charAt(0) == '1') {
  780	            obj.stack1 = reverse(obj.stack[obj.tos]);
  781	            i = 0 - Hextoany.bintodecimal(obj.stack1);
  782	        } else {
  783	            i = Hextoany.bintodecimal(obj.stack[obj.tos]);
  784	        }







2018-05-01 14:11                    CPU.java                     Page 15


  785	        return i;
  786	    }
  787	
  788	    // calculates effective address
  789	    static String index(PCB obj) throws ERROR_HANDLER {
  790	        String len1;
  791	        String g = Integer.toBinaryString(Hextoany.bintodecimal(obj.ir.substring(9, obj.ir.length())) +
  792	                Integer.parseInt(obj.br));
  793	        String g1 = cut(g);
  794	        if (obj.ir.charAt(6) == '1') {
  795	
  796	            len1 = MEMORY.Memory_function("read", g1, obj.stack[obj.tos], obj);
  797	        } else {
  798	            len1 = MEMORY.Memory_function("read", g1, "0", obj);
  799	
  800	        }
  801	        return len1;
  802	    }
  803	
  804	
  805	
  806	    // trims an instruction if it has more than 16 bits
  807	    static String trim(String ins) {
  808	        String len;
  809	        StringBuilder sb = new StringBuilder(ins);
  810	        sb.reverse();
  811	        String sb1 = sb.substring(0, 16);
  812	        StringBuilder sb2 = new StringBuilder(sb1);
  813	        len = sb2.reverse().toString();
  814	        return len;
  815	    }
  816	
  817	    //outputs te final result
  818	
  819	
  820	}



























2018-04-30 01:55                    DISK.java                     Page 1


    1	/**
    2	 * The DISK module is used by the SYSTEM, LOADER, CPU to spool the data of the input.txt jobs and read the data respectively.
    3	 * It consists of fmbv_disk and disk as global variables which specifies the available disk frame to spool the job data
    4	 * and disk is used to store and read the data.
    5	 */
    6	public class DISK {
    7	
    8	
    9	    public static String disk_fun(String x, String y, String z) throws ERROR_HANDLER {
   10	        // read the data from the disk
   11	        try{
   12	        if (x.equals("read")) {
   13	            return (SYSTEM.disk[Integer.parseInt(y)]);
   14	
   15	        }
   16	        //write data to the disk
   17	        else if (x.equals("write")) {
   18	
   19	            SYSTEM.disk[Integer.parseInt(y)] = z;
   20	        } else {
   21	            throw new ERROR_HANDLER(15);
   22	        }
   23	        return "";
   24	    }catch (Exception e){
   25	            throw new ERROR_HANDLER(15);
   26	
   27	        }
   28	
   29	    }
   30	
   31	}
   32	
   33	






























2018-04-29 21:13                ERROR_HANDLER.java                Page 1


    1	/** ERROR_HANDLER class is called once an error is triggered anywhere in the SYSTEM, MEMORY, CPU
    2	 * Upon receiving the error it returns the error message and the control to the SYSTEM.
    3	 * */
    4	
    5	
    6	public class ERROR_HANDLER extends Exception  {
    7	    // Constructor which returns the error message to SYSTEM.
    8	    ERROR_HANDLER(int error) {
    9	
   10	        super(get_error_msg(error));
   11	
   12	
   13	
   14	    }
   15	
   16	    static String get_error_msg(int error) {
   17	        switch (error){
   18	            //if the arguments of the file i.e the file name is wrongly specified
   19	            case 0:
   20	                return "File not found";
   21	            // br not specified properly
   22	            case 1:
   23	                return "Base register overflow error";
   24	            // objpc not specified properly
   25	            case 2:
   26	                return "Program counter overflow error";
   27	            //trace file bit is not entered properly
   28	            case 3:
   29	                return "Trace flag error";
   30	            case 4:
   31	                return "**INPUT is Missing from its place in input.txt job";
   32	            case 5:
   33	                return "**FIN is Missing from its place in input.txt job";
   34	            case 6:
   35	                return "Missing **JOB in input.txt file";
   36	            case 7:
   37	                return "Missing elements in **JOB line in input.txt file";
   38	            case 8:
   39	                return "Input Argument Overflowed";
   40	            case 9:
   41	                return " arguments error";
   42	            case 10:
   43	                return "File not found";
   44	            case 11:
   45	                return "Infinite job error";
   46	            case 12:
   47	                return "Stack underflow error for the job";
   48	            case 13:
   49	                return "Stack overflow error for the job";
   50	            case 14:
   51	                return "Invalid memory operation";
   52	            case 15:
   53	                return "Invalid Disk operation";
   54	            case 16:
   55	                return "Divide by zero exception";
   56	            case 17:







2018-04-29 21:13                ERROR_HANDLER.java                Page 2


   57	                return "Conflict between no of input.txt words specified in **JOB line of the job and no of input.txt items " +
   58	                        "given in the INPUT section";
   59	            case 18:
   60	                return "Conflict between size of Program words specified and no of program items given in the " +
   61	                        "program section";
   62	            case 19:
   63	                return "Missing/improper Loader format in input.txt file";
   64	            case 20:
   65	                return "More than one **INPUT statement";
   66	            case 21:
   67	                return "Reading beyond the specified Input-Data-segment";
   68	            case 22:
   69	                return "Writing beyond the specified Output-Data-segment";
   70	        }
   71	        return "";
   72	    }
   73	}














































2018-05-01 13:32                FAULT_HANDLER.java                Page 1


    1	/**
    2	 * The FAULT_HANDLER class consists of two functions Segment_fault_Handler and page_fault_handler which performs segment faults
    3	 * and page faults respectively as the name suggests when necessary.
    4	 */
    5	public class FAULT_HANDLER {
    6	
    7	    //handles segment faults usually occurs for first read and write operations
    8	    static void segment_fault_handler(PCB seg, String s) {
    9	        if (s.equals("input.txt")) {
   10	            seg.flag_segmentfault_input = 0;
   11	            seg.segment_fault_time = seg.segment_fault_time + 5;
   12	            seg.run_time = seg.run_time + 5;
   13	            seg.input_data_segment_pointer = seg.pages.get("program_page_size");
   14	        }
   15	        if (s.equals("output")) {
   16	            seg.flag_segmentfault_output = 0;
   17	            seg.segment_fault_time = seg.segment_fault_time + 5;
   18	            seg.run_time = seg.run_time + 5;
   19	            seg.output_data_segment_pointer = (seg.pages.get("program_page_size") + seg.pages.get("input_page_size"));
   20	        }
   21	
   22	
   23	    }
   24	
   25	    //this function handles pagefaults when the required page is not in the memory.
   26	    static String page_fault_handler(int ea, PCB obj) throws ERROR_HANDLER {
   27	        String[] segment_word = new String[8];
   28	        obj.page_fault_time = obj.page_fault_time + 20;
   29	        obj.run_time = obj.run_time + 20;
   30	        obj.page_fault++;
   31	        int fc = obj.frame_count;
   32	        if (fc < obj.no_of_frames) {
   33	            int index = ea * 8, k = 0;
   34	            //getting values from disk starting from page index
   35	            for (int i = index; i < index + 8; i++) {
   36	                segment_word[k] = SYSTEM.disk[i];
   37	                k++;
   38	            }
   39	            k = 0;
   40	            // pushing values to memory into index retrieved from pcb arraylist frame using frame_count
   41	            int mem_index = obj.frame.get(obj.frame_count);
   42	            for (int i = mem_index; i < mem_index + 8; i++) {
   43	                SYSTEM.memory_variable[i] = Hextoany.hexToBinary(segment_word[k]);
   44	                k++;
   45	            }
   46	
   47	            obj.pmt[obj.current_page].page_number = Integer.toString(obj.current_page);
   48	            obj.pmt[obj.current_page].frame_number = Integer.toString(mem_index / 8);
   49	            obj.pmt[obj.current_page].valid_invalid = "1";
   50	            obj.frame_count++;
   51	
   52	        } else {
   53	//page fault replacement algorithm-Enhanced second chance
   54	            int[] page_replace = new int[obj.frame.size()];
   55	            int flag = 0, flag1 = 0;
   56	







2018-05-01 13:32                FAULT_HANDLER.java                Page 2


   57	            //placing all the indexes of the pages that are present in the allocated memory frames.
   58	            for (int i = 0; i < page_replace.length; i++) {
   59	
   60	                for (int j = 0; j < obj.total_pages; j++) {
   61	
   62	                    if (obj.pmt[j].frame_number.equals(Integer.toString(obj.frame.get(i) / 8))) {
   63	
   64	                        page_replace[i] = Integer.parseInt(obj.pmt[j].page_number);
   65	                        break;
   66	                    }
   67	                }
   68	            }
   69	
   70	
   71	            while (flag1 == 0) {
   72	
   73	                for (int i = obj.faulty_pointer, count = 0; i < obj.frame.size() && count != obj.frame.size(); i++, count++) {
   74	                    //Cycle through the buffer looking for <reference_bit=0, dirty_bit=0>. If one is found, use that page.
   75	                    if (obj.pmt[page_replace[i]].reference_bit.equals("0") && obj.pmt[page_replace[i]].dirty_bit.equals("0")) {
   76	                        obj.pmt[page_replace[i]].valid_invalid = "0";
   77	                        obj.pmt[page_replace[i]].frame_number = "";
   78	                        int index = ea * 8, k = 0;
   79	                        //getting values from disk starting from page index
   80	                        for (int p = index; p < index + 8; p++) {
   81	                            segment_word[k] = SYSTEM.disk[p];
   82	                            k++;
   83	                        }
   84	                        k = 0;
   85	                        int mem_index = obj.frame.get(i);
   86	                        for (int q = mem_index; q < mem_index + 8; q++) {
   87	                            if (segment_word[k].equals("")|| segment_word[k]==null) {
   88	                                SYSTEM.memory_variable[q] = "";
   89	                            } else {
   90	                                SYSTEM.memory_variable[q] = Hextoany.hexToBinary(segment_word[k]);
   91	                            }
   92	
   93	                            k++;
   94	                        }
   95	
   96	                        obj.pmt[obj.current_page].page_number = Integer.toString(obj.current_page);
   97	                        obj.pmt[obj.current_page].frame_number = Integer.toString(mem_index / 8);
   98	                        obj.pmt[obj.current_page].valid_invalid = "1";
   99	                        obj.pmt[obj.current_page].reference_bit = "0";
  100	                        obj.pmt[obj.current_page].dirty_bit = "0";
  101	                        flag = 1;
  102	                        flag1 = 1;
  103	                        obj.faulty_pointer = i;
  104	                        break;
  105	                    }
  106	                    if (i == obj.frame.size() - 1) {
  107	                        i = -1;
  108	                    }
  109	
  110	                }
  111	
  112	                if (flag == 0) {







2018-05-01 13:32                FAULT_HANDLER.java                Page 3


  113	                    // Cycle through the buffer looking for <reference_bit=0, dirty_bit=1>. Set the use bit to zero
  114	                    // for all frames bypassed.
  115	                    for (int i = obj.faulty_pointer, count = 0; i < obj.frame.size() && count != obj.frame.size(); i++, count++) {
  116	
  117	                        if (obj.pmt[page_replace[i]].reference_bit.equals("0") && obj.pmt[page_replace[i]].dirty_bit.equals("1")) {
  118	                            obj.pmt[page_replace[i]].valid_invalid = "0";
  119	                            obj.pmt[page_replace[i]].frame_number = "";
  120	                            obj.pmt[page_replace[i]].dirty_bit = "0";
  121	                            int index = ea * 8, k = 0;
  122	                            //getting values from disk starting from page index
  123	                            for (int p = index; p < index + 8; p++) {
  124	                                segment_word[k] = SYSTEM.disk[p];
  125	                                k++;
  126	                            }
  127	                            //writing back to disk as dirty bit is 1
  128	                            int mem_index = obj.frame.get(i);
  129	                            k = mem_index;
  130	                            int disk_index = obj.disk_map.get(Integer.parseInt(obj.pmt[page_replace[i]].page_number)) ;
  131	                            for (int q = disk_index; q < disk_index + 8; q++) {
  132	                                String s;
  133	                                if (SYSTEM.memory_variable[k].equals("")) {
  134	                                    s = "";
  135	                                } else {
  136	                                    s = Hextoany.Binarytohex(SYSTEM.memory_variable[k]);
  137	                                }
  138	                                int len = s.length();
  139	
  140	                                StringBuffer sb = new StringBuffer(s);
  141	                                sb.reverse();
  142	                                for (int u = 0; u < 4 - len; u++) {
  143	                                    sb.append('0');
  144	                                }
  145	                                s = sb.reverse().toString();
  146	                                SYSTEM.disk[q] = s;
  147	
  148	                                k++;
  149	                            }
  150	                            k = 0;
  151	                            //writing the required page to the respective page
  152	                            for (int q = mem_index; q < mem_index + 8; q++) {
  153	                                if (segment_word[k].equals("")) {
  154	                                    SYSTEM.memory_variable[q] = "";
  155	                                } else {
  156	                                    SYSTEM.memory_variable[q] = Hextoany.hexToBinary(segment_word[k]);
  157	                                }
  158	                                k++;
  159	                            }
  160	                            obj.pmt[obj.current_page].page_number = Integer.toString(obj.current_page);
  161	                            obj.pmt[obj.current_page].frame_number = Integer.toString(mem_index / 8);
  162	                            obj.pmt[obj.current_page].valid_invalid = "1";
  163	                            obj.pmt[obj.current_page].reference_bit = "0";
  164	                            obj.pmt[obj.current_page].dirty_bit = "0";
  165	
  166	                            flag = 1;
  167	                            flag1 = 1;
  168	                            obj.faulty_pointer = i;







2018-05-01 13:32                FAULT_HANDLER.java                Page 4


  169	                            break;
  170	                        } else {
  171	
  172	                            obj.pmt[page_replace[i]].reference_bit = "0";
  173	
  174	                        }
  175	                        if (i == obj.frame.size() - 1) {
  176	                            i = -1;
  177	                        }
  178	                    }
  179	
  180	                }
  181	                if (obj.faulty_pointer == obj.frame.size()) {
  182	                    obj.faulty_pointer = 0;
  183	
  184	                }
  185	
  186	
  187	            }
  188	
  189	
  190	        }
  191	
  192	        return "";
  193	    }
  194	}





































2018-02-26 22:17                  Hextoany.java                   Page 1


    1	import java.math.BigInteger;
    2	
    3	class Hextoany {
    4	    static String hexToBinary(String hex) {
    5	
    6	        String bin = "";
    7	        String binfr = "";
    8	        int iHex;
    9	        hex = hex.trim();
   10	        hex = hex.replaceFirst("0x", "");
   11	
   12	        for (int i = 0; i < hex.length(); i++) {
   13	            iHex = Integer.parseInt("" + hex.charAt(i), 16);
   14	            binfr = Integer.toBinaryString(iHex);
   15	
   16	            while (binfr.length() < 4) {
   17	                binfr = "0" + binfr;
   18	            }
   19	            bin += binfr;
   20	        }
   21	        return bin;
   22	
   23	    }
   24	
   25	    static String Binarytohex(String binaryStr) {
   26	        if (binaryStr == null) {
   27	            binaryStr = "0";
   28	        }
   29	        int decimal = Integer.parseInt(binaryStr, 2);
   30	        String hexStr = Integer.toString(decimal, 16);
   31	        return hexStr;
   32	    }
   33	
   34	    static String hexTodecimal(String hex) {
   35	        return new BigInteger(hex, 16).toString(10);
   36	    }
   37	
   38	    static int bintodecimal(String bin) {
   39	        int decimal;
   40	        return decimal = Integer.parseInt(bin, 2);
   41	    }
   42	
   43	    static String pad(String a) {
   44	        int len = a.length();
   45	
   46	        StringBuffer sb = new StringBuffer(a);
   47	        sb.reverse();
   48	        for (int i = 0; i < 16 - len; i++) {
   49	            sb.append('0');
   50	        }
   51	        return sb.reverse().toString();
   52	    }
   53	}










2018-05-01 16:28                   LOADER.java                    Page 1


    1	/**
    2	 * Upon the SYSTEM's order LOADER loads the user job to memory. SYSTEM sends the base address, trace_flag
    3	 * as parameters which helps LOADER in loading the program in the MEMORY.
    4	 */
    5	import java.io.FileWriter;
    6	import java.io.IOException;
    7	import java.io.PrintWriter;
    8	
    9	class LOADER {
   10	
   11	    @SuppressWarnings("unchecked")
   12	    public static void Loader_fun(String br, int trace_flag, PCB a) throws ERROR_HANDLER, IOException {
   13	        if (a.trace_flag.equals("1")) {
   14	            a.pw = new PrintWriter(new FileWriter(System.getProperty("user.dir") + "/tracefile_" + a.given_id+"_"+a.job_id+".txt"));
   15	        }
   16	        if (a.trace_flag.equals("1")) {
   17	            a.pw.println(String.format(
   18	                    "%30s%17s%10s%15s\r\n", "", "Before  execution", "",
   19	                    "After  execution"));
   20	            a.pw.println(String.format(
   21	                    "%7s%8s%6s%8s%7s%7s%7s%7s%7s%7s%7s\r\n", "HEX",
   22	                    "HEX", "HEX", "HEX", " HEX", "HEX", " HEX",
   23	                    "HEX", " HEX", "HEX", " HEX"));
   24	            a.pw.println(String.format(
   25	                    "%7s%8s%6s%8s%7s%7s%7s%7s%7s%7s%7s\r\n", "PC",
   26	                    "BR", "IR", "TOS", "S[TOS]", "EA", "(EA)",
   27	                    "TOS", "S[TOS]", "EA", "(EA)"));
   28	        }
   29	         int initial_load, k = 0, initial_availableframe=0,  initial_pageno, frame_address;
   30	         String[] word = new String[8];
   31	
   32	
   33	        initial_load = (a.disk_map.get(a.pc/8)) ;
   34	        k=0;
   35	        for (int i = initial_load; i < initial_load + 8; i++) {
   36	            word[k] = DISK.disk_fun("read", Integer.toString(i), "");
   37	            word[k] = Hextoany.hexToBinary(word[k]);
   38	            k++;
   39	        }
   40	
   41	        // the page is loaded into the available memory frame
   42	        for (int i = 0; i < SYSTEM.fmbv.length; i++) {
   43	            if (SYSTEM.fmbv[i] == 0) {
   44	                SYSTEM.fmbv[i] = 1;
   45	                initial_availableframe = i;
   46	                break;
   47	            }
   48	        }
   49	        a.program_segment_pointer = 0;
   50	        a.pcb_fun();
   51	        a.pmt[a.pc/8].page_number = Integer.toString(a.pc/8);
   52	        a.pmt[a.pc/8].frame_number = Integer.toString(initial_availableframe);
   53	        a.pmt[a.pc/8].valid_invalid = "1";
   54	        frame_address = (initial_availableframe * 8) + Integer.parseInt(a.br);
   55	        k = 0;
   56	        for (int i = frame_address; i < frame_address + 8; i++) {







2018-05-01 16:28                   LOADER.java                    Page 2


   57	            SYSTEM.memory_variable[i] = word[k];
   58	            k++;
   59	        }
   60	        a.frame_count++;
   61	        a.frame.add(frame_address);
   62	        int totpage = a.no_of_frames, avav = 0;
   63	        // the remaining frame base address for the job is stored in frame of PCB
   64	        while (totpage > 1) {
   65	            for (int i = 0; i < SYSTEM.fmbv.length; i++) {
   66	                if (SYSTEM.fmbv[i] == 0) {
   67	                    SYSTEM.fmbv[i] = 1;
   68	                    avav = i;
   69	                    break;
   70	                }
   71	            }
   72	
   73	            a.frame.add(avav * 8);
   74	            totpage--;
   75	        }
   76	
   77	
   78	    }
   79	
   80	}







































2018-05-01 13:29                   MEMORY.java                    Page 1


    1	/**
    2	 * The MEMORY module is used by the LOADER, CPU to read or write instructions.
    3	 * memory_variable and fmbv are the Global variables
    4	 * memory variable stores the job instructions and fmbv specifies the available memory frame.
    5	 */
    6	class MEMORY {
    7	
    8	
    9	
   10	    static String Memory_function(String x, String y, String z, PCB obj) throws ERROR_HANDLER {
   11	        int ea;
   12	        try {
   13	            // read from memory
   14	            if (x.equals("read")) {
   15	                ea = (obj.disk_map.get(Hextoany.bintodecimal(y) / 8)) / 8;
   16	                // checks whether the page is present in the memory if not it causes a pagefault
   17	                //and the control is transferred back to the CPU which in turn transfers to SYSTEM.
   18	                if (obj.pmt[(Hextoany.bintodecimal(y) / 8)].valid_invalid.equals("0")) {
   19	                    obj.current_page = (Hextoany.bintodecimal(y) / 8);
   20	                    obj.flag_pagefault = 1;
   21	                    obj.ea_old = ea;
   22	
   23	                    return "pagefault";
   24	
   25	                } else {
   26	                    int frame_no = Integer.parseInt(obj.pmt[(Hextoany.bintodecimal(y) / 8)].frame_number);
   27	                    obj.pmt[(Hextoany.bintodecimal(y) / 8)].reference_bit = "1";
   28	                    ea = frame_no * 8 + (Hextoany.bintodecimal(y) % 8);
   29	                    return SYSTEM.memory_variable[ea];
   30	                }
   31	
   32	
   33	            }
   34	            // write a word to memory
   35	            else if (x.equals("write")) {
   36	
   37	                ea = (obj.disk_map.get(Integer.parseInt(y) / 8)) / 8;
   38	                // checks whether the page is present in the memory if not it causes a pagefault
   39	                //and the control is transferred back to the CPU which in turn transfers to SYSTEM.
   40	                if (obj.pmt[(Integer.parseInt(y) / 8)].valid_invalid.equals("0")) {
   41	                    obj.current_page = (Integer.parseInt(y) / 8);
   42	                    obj.flag_pagefault = 1;
   43	                    obj.ea_old = ea;
   44	
   45	                    return "pagefault";
   46	                } else {
   47	                    int frame_no = Integer.parseInt(obj.pmt[(Integer.parseInt(y) / 8)].frame_number);
   48	                    obj.pmt[(Integer.parseInt(y) / 8)].dirty_bit = "1";
   49	                    ea = frame_no * 8 + (Integer.parseInt(y) % 8);
   50	                    return SYSTEM.memory_variable[ea] = z;
   51	                }
   52	
   53	
   54	            }
   55	        } catch (Exception e) {
   56	            throw new ERROR_HANDLER(14);







2018-05-01 13:29                   MEMORY.java                    Page 2


   57	        }
   58	
   59	        return "";
   60	    }
   61	
   62	
   63	}
























































2018-05-02 11:04               OUTPUTSPOOLING.java                Page 1


    1	/**
    2	 * The OUTSPOOLING class consists output function which displays the Pagemaptable, Job ID, termination type, Input,
    3	 * Output, Memory utilization & fragment size, Disk utilization & fragment size of a respective JOB.
    4	 * It consists of global variable map which stores the page-frame of PMT for every 15 clock vtu's
    5	 * memory_util_word_num, memory_util_word_den, percentage variables are used by ratio function to calculate ratios and
    6	 * percentages.
    7	 */
    8	import java.math.BigInteger;
    9	public class OUTPUTSPOOLING {
   10	
   11	    static void output(PCB obj) throws ERROR_HANDLER {
   12	
   13	
   14	        try {
   15	            if (obj != null) {
   16	                int[] page_replace = new int[obj.frame.size()];
   17	                for (int i = 0; i < page_replace.length; i++) {
   18	
   19	                    for (int j = 0; j < obj.total_pages; j++) {
   20	
   21	                        if (obj.pmt[j].frame_number.equals(Integer.toString(obj.frame.get(i) / 8))) {
   22	                            page_replace[i] = Integer.parseInt(obj.pmt[j].page_number);
   23	                            break;
   24	                        }
   25	                    }
   26	                }
   27	                // writing back the pages in memory to disk which has dirty bit enabled.
   28	                for (int i = 0; i < obj.frame.size(); i++) {
   29	
   30	                    if (obj.pmt[page_replace[i]].dirty_bit.equals("1")) {
   31	
   32	                        obj.pmt[page_replace[i]].valid_invalid = "0";
   33	                        obj.pmt[page_replace[i]].frame_number = "";
   34	                        obj.pmt[page_replace[i]].dirty_bit = "0";
   35	                        int disk_index = obj.disk_map.get(Integer.parseInt(obj.pmt[page_replace[i]].page_number));
   36	                        int k = obj.frame.get(i);
   37	                        for (int q = disk_index; q < disk_index + 8; q++) {
   38	                            if (SYSTEM.memory_variable[k].equals("")) {
   39	                                SYSTEM.disk[q] = "";
   40	                            } else {
   41	                                SYSTEM.disk[q] = Hextoany.Binarytohex(SYSTEM.memory_variable[k]);
   42	                            }
   43	                            k++;
   44	                        }
   45	
   46	                    }
   47	
   48	                }
   49	                if (obj.exit_flag == 1) {
   50	                    for (int i = 0; i < obj.frame.size(); i++) {
   51	
   52	                        int x = obj.frame.get(i);
   53	                        for (int j = x; j < x + 8; j++) {
   54	                            if (SYSTEM.memory_variable[j] == null) {
   55	                                continue;
   56	                            }







2018-05-02 11:04               OUTPUTSPOOLING.java                Page 2


   57	                            if (SYSTEM.memory_variable[j].equals("")) {
   58	
   59	                                obj.memory_fragment_size++;
   60	                            }
   61	
   62	
   63	                        }
   64	                    }
   65	
   66	                }
   67	
   68	
   69	                SYSTEM.exe.println("\n\n\n\nJOB ID : " + obj.job_id + "  (HEX)");
   70	                if (obj.warningmsg != null) {
   71	                    SYSTEM.exe.println("Termination type : " + obj.termtype + " : " + obj.warningmsg);
   72	                }
   73	                if (obj.termmsg != null) {
   74	                    SYSTEM.exe.println("Termination type :" + obj.termtype + " : " + obj.termmsg);}
   75	                    SYSTEM.exe.print("INPUT SEGMENT DATA FOR JOB " + obj.job_id + " (HEX) : ");
   76	                    for (String s : obj.input
   77	                            ) {
   78	                        SYSTEM.exe.print(s + ",");
   79	                    }
   80	                    SYSTEM.exe.println("");
   81	                    SYSTEM.exe.print("OUTPUT SEGMENT DATA FOR JOB " + obj.job_id + "(BIN) : ");
   82	                    for (String s : obj.output
   83	                            ) {
   84	                        SYSTEM.exe.print(s + ",");
   85	                    }
   86	                    SYSTEM.exe.println("\nCLOCK              : " + Integer.toHexString(SYSTEM.clock) + "  (HEX)" + SYSTEM.clock +
   87	                            "\nARRIVAL TIME       : " + (obj.arrivaltime) + " (DEC)" +
   88	                            "\nDEPARTURE TIME       : " + (obj.departuretime) + " (DEC)" +
   89	                            "\nJOB RUN TIME       : " + (obj.run_time) + " (DEC)" +
   90	                            "\nEXECUTION TIME     : " + (obj.run_time - obj.clock1 - obj.segment_fault_time -
   91	                            obj.page_fault_time) + " (DEC)" +
   92	                            "\nINPUT/OUTPUT TIME  : " + obj.clock1 + "  (DEC)" +
   93	                            "\nNO OF PAGEFAULTS  : " + obj.no_pagefault + "  (DEC)" +
   94	                            "\nNO OF SEGMENT FAULTS  : " + obj.no_segmentfault + "  (DEC)" +
   95	                            "\nSEGMENT FAULT TIME : " + obj.segment_fault_time + "  (DEC)" +
   96	                            "\nPAGE FAULT TIME    : " + obj.page_fault_time + "  (DEC)" + ratio(SYSTEM.memory_variable.length,
   97	                            (obj.frame.size() * 8) - (obj.memory_fragment_size), obj) +
   98	                            "\nMEMORY UTILIZATION IN WORDS : RATIO  : " + obj.memory_util_word_num + "/" + obj.memory_util_word_den
   99	                            + " PERCENTAGE  : " + SYSTEM.decformat.format(obj.percentage) + " %"
  100	                            + ratio(SYSTEM.memory_variable.length / 8, (obj.frame.size()), obj) +
  101	                            "\nMEMORY UTILIZATION IN FRAMES : RATIO : " + obj.memory_util_word_num + "/" + obj.memory_util_word_den
  102	                            + " PERCENTAGE    : " + SYSTEM.decformat.format(obj.percentage) + " %" + ratio(SYSTEM.disk.length, ((obj.total_pages * 8) -
  103	                            (obj.disk_fragment_size)), obj) +
  104	                            "\nDISK UTILIZATION IN WORDS :   RATIO  : " + obj.memory_util_word_num + "/" + obj.memory_util_word_den
  105	                            + " PERCENTAGE : " +SYSTEM.decformat.format(obj.percentage) + " %" + ratio(SYSTEM.disk.length / 8, ((obj.total_pages)), obj) +
  106	                            "\nDISK UTILIZATION IN FRAMES :   RATIO : " + obj.memory_util_word_num + "/" + obj.memory_util_word_den
  107	                            + " PERCENTAGE  : " + SYSTEM.decformat.format(obj.percentage) + " %" +
  108	                            "\nMEMORY FRAGMENT SIZE : " + ((obj.exit_flag == 1) ? obj.memory_fragment_size + "  (DEC)" : " " +
  109	                            "Not yet calculated") +
  110	                            "\nDISK FRAGMENT SIZE   : " + ((obj.exit_flag == 1) ? obj.disk_fragment_size / 3.0 + "  (DEC)"
  111	                            : " Not yet calculated ") +
  112	                            "\nTURN AROUND TIME : " + (Math.abs(obj.departuretime+obj.clock1 - obj.arrivaltime)) + "  (DEC)");







2018-05-02 11:04               OUTPUTSPOOLING.java                Page 3


  113	
  114	
  115	
  116	//destroy jobs PCB and release respective memory and disk pages
  117	
  118	
  119	                if (obj.exit_flag == 1) {
  120	                    for (int i = 0; i < obj.frame.size(); i++) {
  121	
  122	                        int x = obj.frame.get(i);
  123	                        SYSTEM.fmbv[x / 8] = 0;
  124	
  125	                        for (int k = x; k < x + 8; k++) {
  126	
  127	                            SYSTEM.memory_variable[k] = null;
  128	
  129	
  130	                        }
  131	                    }
  132	
  133	
  134	                    for (int i = 0; i < obj.frame_disk.size(); i++) {
  135	
  136	                        int x = obj.frame_disk.get(i);
  137	                        SYSTEM.fmbv_disk[x / 8] = 0;
  138	
  139	                        for (int k = x; k < x + 8; k++) {
  140	
  141	                            SYSTEM.disk[k] = null;
  142	
  143	
  144	                        }
  145	                    }
  146	
  147	
  148	                }
  149	
  150	
  151	            }
  152	
  153	        } catch (Exception e) {
  154	            throw new ERROR_HANDLER(9);
  155	        }
  156	
  157	    }
  158	
  159	
  160	    static String ratio(int x, int y, PCB obj) {
  161	        BigInteger word = BigInteger.valueOf(x);
  162	        int util = y;
  163	        BigInteger frag = BigInteger.valueOf(util);
  164	        BigInteger gc = frag.gcd(word);
  165	        BigInteger numerator = frag.divide(gc);
  166	        BigInteger denominator = word.divide(gc);
  167	        obj.memory_util_word_num = numerator;
  168	        obj.memory_util_word_den = denominator;







2018-05-02 11:04               OUTPUTSPOOLING.java                Page 4


  169	        String val = "100";
  170	        BigInteger value = new BigInteger(val);
  171	        BigInteger percent = numerator.multiply(value);
  172	        obj.percentage = percent.doubleValue() / denominator.doubleValue();
  173	        return "";
  174	    }
  175	
  176	    static void snapshot_fun(PCB obj) {
  177	
  178	        SYSTEM.snapshot_s++;
  179	        int mem_util = SYSTEM.fmbv.length;
  180	        int memory_utilization = 0;
  181	        while (mem_util > 0) {
  182	            if (SYSTEM.fmbv[mem_util - 1] == 1) {
  183	                int y = (mem_util - 1) * 8;
  184	                for (int i = y; i < y + 8; i++) {
  185	                    if (!("").equals(SYSTEM.memory_variable[i])) {
  186	                        memory_utilization++;
  187	                    }
  188	                }
  189	            }
  190	
  191	            mem_util--;
  192	        }
  193	
  194	        int mem_util_disk = SYSTEM.fmbv_disk.length;
  195	        int disk_utilization = 0;
  196	        while (mem_util_disk > 0) {
  197	            if (SYSTEM.fmbv_disk[mem_util_disk - 1] == 1) {
  198	                int y = (mem_util_disk - 1) * 8;
  199	                for (int i = y; i < y + 8; i++) {
  200	                    if (!("").equals(SYSTEM.disk[i])) {
  201	                        disk_utilization++;
  202	                    }
  203	                }
  204	            }
  205	
  206	            mem_util_disk--;
  207	        }
  208	
  209	        int mega = SYSTEM.ready_queue.size();
  210	        int last_size = SYSTEM.blocked_queue.size();
  211	        SYSTEM.exe.print("\n-----------------------------------------" +
  212	                "\n\n -----------------------SNAPSHOT---------------\n" +
  213	                "\nCONTENTS OF READY QUEUE         (DEC): ");
  214	        if(mega==0){SYSTEM.exe.print(" NO ELEMENT");}
  215	        while (mega > 0) {
  216	            int x = SYSTEM.ready_queue.poll();
  217	            SYSTEM.exe.print(x + ",");
  218	            SYSTEM.ready_queue.add(x);
  219	            mega--;
  220	        }
  221	        SYSTEM.exe.print(
  222	
  223	                "\nJOB ID CURRENTLY EXECUTING      (DEC): " + SYSTEM.job_id.get(obj));
  224	







2018-05-02 11:04               OUTPUTSPOOLING.java                Page 5


  225	        SYSTEM.exe.println("\nPMT  ");
  226	        SYSTEM.exe.println("Page number  frame number");
  227	        for (int i = 0; i < obj.frame.size(); i++) {
  228	
  229	            for (int j = 0; j < obj.total_pages; j++) {
  230	
  231	                if (obj.pmt[j].frame_number.equals(Integer.toString(obj.frame.get(i) / 8))) {
  232	
  233	                    SYSTEM.exe.println("    " + obj.pmt[j].page_number + "      -     " + obj.pmt[j].frame_number);
  234	                    break;
  235	                }
  236	            }
  237	        }
  238	        SYSTEM.exe.print("\nCONTENTS OF BLOCKED QUEUE       (DEC): ");
  239	        if(last_size==0){SYSTEM.exe.print(" NO ELEMENT");}
  240	        while (last_size > 0) {
  241	            int x = SYSTEM.blocked_queue.poll();
  242	            SYSTEM.exe.print(x + ",");
  243	            SYSTEM.blocked_queue.add(x);
  244	            last_size--;
  245	        }
  246	        SYSTEM.exe.print(
  247	                "\nDEGREE OF MULTIPROGRAMMING      (DEC): " + (SYSTEM.ready_queue.size() + SYSTEM.blocked_queue.size()) +
  248	                        "\nMEMORY UTILIZATION              (DEC): " + SYSTEM.decformat.format((memory_utilization / (32.0 * 8.0)) * 100) + "%" +
  249	                        "\nDISK UTILIZATION                (DEC): " + SYSTEM.decformat.format((disk_utilization / (256.0 * 8.0)) * 100) + "%" +
  250	                        "\n----------------------------------------------\n");
  251	
  252	
  253	        SYSTEM.memory_util_mean= (int) (SYSTEM.memory_util_mean+(memory_utilization / (32.0 * 8.0)) * 100);
  254	        SYSTEM.disk_util_mean= (int) (SYSTEM.disk_util_mean+(disk_utilization / (256.0 * 8.0)) * 100);
  255	    }
  256	
  257	
  258	    static void executionprofile() {
  259	        int x = SYSTEM.infinite_id.size();
  260	
  261	        SYSTEM.exe.println(
  262	                "\n--------------------------------------------" +
  263	
  264	
  265	
  266	                        "\nCLOCK             (HEX): " + Integer.toHexString(SYSTEM.clock) +
  267	                        "\n\n METERING AND REPORTING \n" +
  268	                        "--------------------------------------------------" +
  269	                        "\nNUMBER OF JOBS PROCESSED         (DEC) : " + SYSTEM.jid +
  270	                        "\n\nCPU TIME FOR JOBS THAT TERMINATE NORMALLY " +
  271	                        "\n---MINIMUM       (DEC): " + SYSTEM.cpu_min_time + " " +
  272	                        "\n---MAXIMUM       (DEC): " + SYSTEM.cpu_max_time + " " +
  273	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.cpu_avg_time) + " " +
  274	                        "\n\nTURNAROUND TIME FOR ALL THE JOBS " +
  275	                        "\n---MINIMUM       (DEC): " + SYSTEM.ta_min_time + " " +
  276	                        "\n---MAXIMUM       (DEC): " + SYSTEM.ta_max_time + " " +
  277	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.ta_avg_time) + " " +
  278	                        "\n\nCODE SEGMENT SIZE " +
  279	                        "\n-IN BATCH PACKET       " +
  280	                        "\n---MINIMUM       (DEC): " + SYSTEM.code_min_batch + " " +







2018-05-02 11:04               OUTPUTSPOOLING.java                Page 6


  281	                        "\n---MAXIMUM       (DEC): " + SYSTEM.code_max_batch + " " +
  282	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.code_avg_batch) + " " +
  283	                        "\n-AS COMPUTED BY LOADER       " +
  284	                        "\n---MINIMUM       (DEC): " + SYSTEM.code_min_batch + " " +
  285	                        "\n---MAXIMUM       (DEC): " + SYSTEM.code_max_batch + " " +
  286	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.code_avg_batch) + " " +
  287	                        "\n\nINPUT SEGMENT SIZE " +
  288	                        "\n-IN BATCH PACKET       " +
  289	                        "\n---MINIMUM       (DEC): " + SYSTEM.input_min_batch + " " +
  290	                        "\n---MAXIMUM       (DEC): " + SYSTEM.input_max_batch + " " +
  291	                        "\n---AVERAGE      (DEC) : " + SYSTEM.decformat.format(SYSTEM.input_avg_batch) + " " +
  292	                        "\n-AS COMPUTED BY LOADER       " +
  293	                        "\n---MINIMUM       (DEC): " + SYSTEM.input_min_loader + " " +
  294	                        "\n---MAXIMUM       (DEC): " + SYSTEM.input_max_loader + " " +
  295	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.input_avg_loader) + " " +
  296	                        "\n\nOUTPUT SEGMENT SIZE " +
  297	                        "\n-IN BATCH PACKET       " +
  298	                        "\n---MINIMUM      (DEC) : " + SYSTEM.output_min_batch + " " +
  299	                        "\n---MAXIMUM       (DEC): " + SYSTEM.output_max_batch + " " +
  300	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.output_avg_batch) + " " +
  301	                        "\n-AS COMPUTED BY LOADER       " +
  302	                        "\n---MINIMUM       (DEC): " + SYSTEM.output_min_loader + " " +
  303	                        "\n---MAXIMUM       (DEC): " + SYSTEM.output_max_loader + " " +
  304	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.output_avg_loader) + " " +
  305	                        "\n\nCPU SHOTS " +
  306	                        "\n---MINIMUM       (DEC): " + SYSTEM.cpushot_min + " " +
  307	                        "\n---MAXIMUM       (DEC): " + SYSTEM.cpushot_max + " " +
  308	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.cpushot_avg) + " " +
  309	                        "\n\nI/0 REQUESTS " +
  310	                        "\n---MINIMUM       (DEC): " + SYSTEM.io_min + " " +
  311	                        "\n---MAXIMUM       (DEC): " + SYSTEM.io_max + " " +
  312	                        "\n---AVERAGE       (DEC): " + SYSTEM.decformat.format(SYSTEM.io_avg) + " \n" +
  313	                        "----------------------------------------------------------\n" +
  314	
  315	                        "-----------------------------------------------------------" +
  316	                        "\n\nJOBS THAT TERMINATED NORMALLY (DEC): " + SYSTEM.normal_termination + " \n" +
  317	                        "\n\nJOBS THAT TERMINATED ABNORMALLY (DEC): " + SYSTEM.abnormal_termination + " \n" +
  318	                        "\n\nTIME LOST DUE TO ABNORMAL TERMINATION OF JOBS :" + SYSTEM.time_abnormal_termination + " \n" +
  319	                        "\n\nTIME LOST DUE SUSPECTED INFINITE JOBS (DEC):" + SYSTEM.suspected_infinite + " (DEC)\n" +
  320	                        "\n\nID'S OF JOBS SUSPECTED INFINITE (DEC):");
  321	        for (int i = 0; i < x; i++) {
  322	            SYSTEM.exe.print(SYSTEM.infinite_id.get(0) + ",");
  323	        }
  324	
  325	        SYSTEM.exe.print(
  326	
  327	                "\n\nMEAN TURN AROUND TIME OF JOBS THAT TERMINATED NORMALLY (DEC): " + SYSTEM.decformat.format(SYSTEM.mean_tat / SYSTEM.jid) + " \n" +
  328	                        "\n\nMEAN WAITING TIME OF JOBS THAT TERMINATED NORMALLY (DEC): " + SYSTEM.decformat.format(SYSTEM.mean_wt / SYSTEM.jid) + " \n" +
  329	                        "\n\nMEAN NUMBER OF PAGEFAULTS (DEC): " + SYSTEM.decformat.format(SYSTEM.pagefault_value / SYSTEM.jid) + " \n" +
  330	                        "\n\nMEAN MEMORY UTILIZATION OVER ALL SAMPLING INTERVALS (DEC): " + SYSTEM.decformat.format(SYSTEM.memory_util_mean/SYSTEM.snapshot_s) + "% \n" +
  331	                        "\n\nMEAN DISK UTILIZATION OVER ALL SAMPLING INTERVALS (DEC): "+SYSTEM.decformat.format(SYSTEM.disk_util_mean/SYSTEM.snapshot_s) + " %\n"
  332	
  333	        );
  334	        SYSTEM.exe.close();
  335	
  336	    }







2018-05-02 11:04               OUTPUTSPOOLING.java                Page 7


  337	
  338	}
  339	
  340	



























































2018-05-01 15:34                     PCB.java                     Page 1


    1	/**
    2	 * The PCB(ProcessControlBlock) class consists of variables that are unique to every job. These variables describe the
    3	 * state and characteristic of the respective job.
    4	 */
    5	import java.io.PrintWriter;
    6	import java.math.BigInteger;
    7	import java.util.ArrayList;
    8	import java.util.HashMap;
    9	
   10	
   11	public class PCB {
   12	     int input_flag = 0, output_flag = 0, program_flag = 0, in_flag=0;
   13	    String[] stack = new String[8];
   14	     int no_of_frames=0,pc,pc_old,ea = 0;
   15	    String stack1;
   16	    int job_id, tos = 0, clock1=0, virtualclock = 0, time = 0, instriction_type, overflow_flag;
   17	    //stores the current objpc of a job
   18	    String br,ir,pc_cpu;
   19	    String  trace_flag;
   20	    BigInteger memory_util_word_num, memory_util_word_den;
   21	    double percentage;
   22	    String termtype, warningmsg, termmsg, blocked_status;
   23	    //input.txt,output,program segment sizes of a job
   24	    int input_segment_size, output_segment_size, memory_utilization,program_segment_size, total_pages, blocked_time, loader_flag=0, disk_page_count=-1;
   25	    //points to the program PMT
   26	    int program_segment_pointer, executiontime, no_pagefault=0, no_segmentfault=0,given_id;
   27	     HashMap<Integer,Integer > disk_map= new HashMap<>();
   28	    PrintWriter pw;
   29	    //points to input.txt PMT
   30	    int input_data_segment_pointer, internal_jid, arrivaltime, departuretime;
   31	    int input_data_segment_index=0;
   32	    int run_time=0, execution_time_in_cpu, execution_flag=0, current_page, input_size=0, output_size=0,cpushot=0,ioshot=0, infinite_time=0;
   33	    //points to output PMT
   34	    int output_data_segment_pointer, error_flag_input=0, job_error=0;
   35	    //count on no of available frames used
   36	    int frame_count = 0;
   37	    //count on pagefaults for respective job
   38	    int page_fault=0,pmt_index,totpage;
   39	    int page_fault_time=0;
   40	    int segment_fault_time=0;
   41	    //Flag for input.txt segment fault
   42	    int flag_segmentfault_input=0,pcc;
   43	    //Flag for output segment fault
   44	    int flag_segmentfault_output=0;
   45	    int ea_old;
   46	    int flag_input=0;
   47	    int flag_output=0;
   48	    int flag_pagefault=0;
   49	    int exit_flag=0;
   50	    ArrayList<String> map = new ArrayList<>();
   51	    //stores all inputs
   52	    ArrayList<String> input=new ArrayList<>();
   53	    //stores all outputs
   54	    ArrayList<String> output=new ArrayList<>();
   55	    int clock=0;
   56	    //page fault pointer for the particular job







2018-05-01 15:34                     PCB.java                     Page 2


   57	    int faulty_pointer = 0,halt_flag=0;
   58	    int disk_fragment_size=0;
   59	    int memory_fragment_size=0;
   60	    int output_data_segment_index=0;
   61	    String read;
   62	    String write;
   63	    //this arraylist called frame holds the base address of the frames assigned to a job
   64	    ArrayList<Integer> frame = new ArrayList<Integer>(6);
   65	    ArrayList<Integer> frame_disk = new ArrayList<Integer>();
   66	    //Holds No of Pages for each segment
   67	    HashMap<String, Integer> pages = new HashMap<>();
   68	    //Each segment index in disk
   69	    HashMap<String, Integer> segment_index = new HashMap<>(3);
   70	    //pmt objects which are used by smt
   71	    PMT[] pmt;
   72	
   73	    public void pcb_fun() {
   74	        pmt = new PMT[total_pages];
   75	        for (int i = 0; i < pmt.length; i++)
   76	            pmt[i] = new PMT();
   77	    }
   78	}









































2018-04-02 23:53                     PMT.java                     Page 1


    1	/**
    2	 * The PMT(PageMapTable) class consists of variables that describe the characteristics of the pages that
    3	 * are present in the memory frames for a job.
    4	 */
    5	public class PMT {
    6	
    7	    String page_number = "";
    8	    String frame_number = "";
    9	    String  valid_invalid = "0";
   10	    String reference_bit = "0";
   11	    String dirty_bit = "0";
   12	
   13	}


















































2018-05-02 10:44                   SYSTEM.java                    Page 1


    1	/**
    2	 * BUJULA JAYANTH REDDY
    3	 * CS5323
    4	 * A Simple Batch System
    5	 * 02/27/2018
    6	 * Global Variables:
    7	 * clock - Which stores the total running time of a user job.
    8	 * termtype - Describes termination type of the exception
    9	 * warningmsg - contains the warning message caused by the exception
   10	 * termmsg - contains the termination message caused by exception
   11	 * filereader- used to read the file path
   12	 * bufferedReader- used by file reader to get characters from a file.
   13	 * output_flag- It is used to determine available frame in disk.
   14	 * input_flag- It is used to determine the available frame in memory.
   15	 * ready_queue- stores the processes ids that are ready to execute
   16	 * The SYSTEM class is the heart of the simple batch batch system that is designed.
   17	 * It controls all the other components like LOADER, MEMORY, CPU, ERROR_HANDLER.
   18	 * It continuously checks whether if there are any user jobs and calls loader to load the jobs to MEMORY if present
   19	 * and calls CPU for execution of the job.
   20	 */
   21	
   22	import java.io.*;
   23	import java.text.DecimalFormat;
   24	import java.util.ArrayList;
   25	import java.util.HashMap;
   26	import java.util.LinkedList;
   27	import java.util.Queue;
   28	
   29	
   30	public class SYSTEM {
   31	    static BufferedReader bufferedReader;
   32	    static String file;
   33	    static int clock = 0,snapshot=0, memoryaddress, error = 0, loader_flag = 1, jid = 0, available_memory_size = 32, count_inputfile = 0, count_halt = 0, haltflag = 0, disk_page_count = 0, finale = 0;
   34	    static HashMap<Integer, PCB> pcb = new HashMap<>();
   35	    static HashMap<PCB, Integer> job_id = new HashMap<>();
   36	    static PCB[] aa = new PCB[100000];
   37	    static Queue<Integer> ready_queue = new LinkedList<>();
   38	    static Queue<Integer> blocked_queue = new LinkedList<>();
   39	    static String[] memory_variable = new String[256];
   40	    static int[] fmbv = new int[32];
   41	    static int[] fmbv_disk = new int[256];
   42	    static String[] disk = new String[2048];
   43	    static PCB currentjob, currentjob2;
   44	    static PrintWriter exe;
   45	    static int noofjobs = 0,tat=0,normal_tat=0,normal_wt;
   46	    static int cpu_min_time = 0;
   47	    static int cpu_max_time = 0;
   48	    static double cpu_avg_time = 0;
   49	    static int ta_min_time = 0;
   50	    static int ta_max_time = 0;
   51	    static double ta_avg_time = 0;
   52	    static int code_min_batch = 0;
   53	    static int code_max_batch = 0;
   54	    static double code_avg_batch = 0;
   55	    static int input_min_batch = 0;
   56	    static int input_max_batch = 0;







2018-05-02 10:44                   SYSTEM.java                    Page 2


   57	    static double input_avg_batch = 0;
   58	    static int input_min_loader = 0;
   59	    static int input_max_loader = 0;
   60	    static double input_avg_loader = 0;
   61	    static int output_min_batch = 0;
   62	    static int output_max_batch = 0;
   63	    static double output_avg_batch = 0;
   64	    static int output_min_loader = 0;
   65	    static int output_max_loader = 0;
   66	    static double output_avg_loader = 0;
   67	    static int cpushot_min = 0;
   68	    static int cpushot_max = 0,clock_idle=0;
   69	    static double cpushot_avg = 0, mean_pagefault_value=0;
   70	    static int io_min = 0, pagefault_value=0;
   71	    static int io_max = 0, normal_termination=0,abnormal_termination=0, time_abnormal_termination=0, suspected_infinite=0;
   72	    static double io_avg = 0, mean_tat=0, mean_wt=0;
   73	    static ArrayList<Integer> infinite_id= new ArrayList<>();
   74	    static DecimalFormat decformat= new DecimalFormat("0.00");
   75	    static int snapshot_s = 0;
   76	    static int memory_util_mean=0, disk_util_mean=0;
   77	
   78	    public static void main(String[] args) throws ERROR_HANDLER, IOException {
   79	
   80	        // checks whether an argument is passed to the SYSTEM
   81	         file=args[0];
   82	        try {
   83	            bufferedReader = new BufferedReader(new FileReader(
   84	                    file));
   85	
   86	        } catch (FileNotFoundException e) {
   87	            System.out.println("File not found");
   88	            System.exit(0);
   89	
   90	        }
   91	        exe = new PrintWriter(new FileWriter(System.getProperty("user.dir") + "/Execution_profile.txt"),true);
   92	        Inputspooling(bufferedReader);
   93	        while (true) {
   94	            try {
   95	
   96	                if ((ready_queue.size() == 0 && blocked_queue.size() == 0) || (haltflag == 1 && finale != 1) || (error == 1 && finale != 1)) {
   97	                    String read;
   98	                    error = 0;
   99	                    if ((read = bufferedReader.readLine()) == null) {
  100	                        break;
  101	                    }
  102	                    count_inputfile++;
  103	
  104	                    bufferedReader = new BufferedReader(new FileReader(
  105	                            file));
  106	                    String read1 = "";
  107	                    count_inputfile = count_inputfile - 3;
  108	                    for (int i = 0; i < count_inputfile; i++) {
  109	                        read1 = bufferedReader.readLine();
  110	                    }
  111	                    Inputspooling(bufferedReader);
  112	







2018-05-02 10:44                   SYSTEM.java                    Page 3


  113	                }
  114	
  115	
  116	                while (ready_queue.size() == 0 && blocked_queue.size() > 0) {
  117	                    clock_idle++;
  118	                    clock++;
  119	                    blockedcheck();
  120	                }
  121	                // if(ready_queue.size()<=0) {System.exit(0);}
  122	                String job_element = String.valueOf(ready_queue.poll());
  123	
  124	
  125	                PCB a = pcb.get(Integer.parseInt(job_element));
  126	                currentjob = a;
  127	                if (loader_flag == 0 && a.loader_flag == 0) {
  128	                    if (a.trace_flag.equals("1")) {
  129	                        a.pw = new PrintWriter(new FileWriter(System.getProperty("user.dir") + "/tracefile_" + a.given_id+"_"+a.job_id+".txt"));
  130	                    }
  131	                    if (a.trace_flag.equals("1")) {
  132	                        a.pw.println(String.format(
  133	                                "%30s%17s%10s%15s\r\n", "", "Before  execution", "",
  134	                                "After  execution"));
  135	                        a.pw.println(String.format(
  136	                                "%7s%8s%6s%8s%7s%7s%7s%7s%7s%7s%7s\r\n", "HEX",
  137	                                "HEX", "HEX", "HEX", " HEX", "HEX", " HEX",
  138	                                "HEX", " HEX", "HEX", " HEX"));
  139	                        a.pw.println(String.format(
  140	                                "%7s%8s%6s%8s%7s%7s%7s%7s%7s%7s%7s\r\n", "PC",
  141	                                "BR", "IR", "TOS", "S[TOS]", "EA", "(EA)",
  142	                                "TOS", "S[TOS]", "EA", "(EA)"));
  143	                    }
  144	                    int avav = 0;
  145	                    // the remaining frame base address for the job is stored in frame of PCB
  146	                    while (a.totpage > 0) {
  147	                        for (int i = 0; i < SYSTEM.fmbv.length; i++) {
  148	                            if (fmbv[i] == 0) {
  149	                                fmbv[i] = 1;
  150	                                avav = i;
  151	                                break;
  152	                            }
  153	                        }
  154	
  155	                        a.frame.add(avav * 8);
  156	                        a.totpage--;
  157	                    }
  158	                    a.pcb_fun();
  159	                    a.loader_flag = 1;
  160	
  161	                } else if (loader_flag == 1) {
  162	                    a.loader_flag = 1;
  163	                    LOADER.Loader_fun(a.br, (Integer.parseInt(a.trace_flag)), a);
  164	                    loader_flag = 0;
  165	                }
  166	
  167	
  168	                PCB x;







2018-05-02 10:44                   SYSTEM.java                    Page 4


  169	
  170	
  171	                x = CPU.cpu_fun(Integer.toString(a.pc), (Integer.parseInt(a.trace_flag)), a);
  172	
  173	                while (true) {
  174	                    //control transfers to system after job releasing the cpu when a pagefault occur
  175	                    if (x.flag_pagefault == 1) {
  176	                        pagefault_value++;
  177	                        x.no_pagefault++;
  178	                        mean_pagefault_value=mean_pagefault_value+(pagefault_value/2.0);
  179	                        x.pc = x.pc_old;
  180	                        blocked_queue.add(job_id.get(x));
  181	                        x.blocked_status = "blocked";
  182	                        x.blocked_time = clock + x.segment_fault_time + x.page_fault_time;
  183	                        FAULT_HANDLER.page_fault_handler(x.ea_old, x);
  184	                        x.flag_pagefault = 0;
  185	                        blockedcheck();
  186	                        break;
  187	                    }
  188	
  189	                    //job releasing cpu after a input.txt segment fault
  190	                    if (x.flag_segmentfault_input == 1) {
  191	                        pagefault_value++;
  192	                        x.no_segmentfault++;
  193	                        mean_pagefault_value=mean_pagefault_value+(pagefault_value/2.0);
  194	                        x.pc = x.pc_old;
  195	                        blocked_queue.add(job_id.get(x));
  196	                        x.blocked_status = "blocked";
  197	                        x.blocked_time = clock + x.segment_fault_time + x.page_fault_time;
  198	                        FAULT_HANDLER.segment_fault_handler(x, "input.txt");
  199	                        blockedcheck();
  200	                        break;
  201	                    }
  202	                    //job releasing cpu after output segment fault
  203	                    if (x.flag_segmentfault_output == 1) {
  204	                        x.no_segmentfault++;
  205	                        pagefault_value++;
  206	                        mean_pagefault_value=mean_pagefault_value+(pagefault_value/2.0);
  207	                        x.pc = x.pc_old;
  208	                        blocked_queue.add(job_id.get(x));
  209	                        x.blocked_status = "blocked";
  210	                        x.blocked_time = clock + x.segment_fault_time + x.page_fault_time;
  211	                        FAULT_HANDLER.segment_fault_handler(x, "output");
  212	                        blockedcheck();
  213	                        break;
  214	                    }
  215	
  216	                    if (x.execution_flag == 1) {
  217	                        x.execution_flag = 0;
  218	                        x.execution_time_in_cpu = 0;
  219	                        int jobid = job_id.get(x);
  220	                        ready_queue.add(jobid);
  221	                        blockedcheck();
  222	                        break;
  223	                    }
  224	                    //exiting jobs from CPU.







2018-05-02 10:44                   SYSTEM.java                    Page 5


  225	                    if (x.halt_flag == 1) {
  226	                        x.departuretime=clock;
  227	                        x.executiontime=x.run_time - x.clock1 - x.segment_fault_time -
  228	                                x.page_fault_time;
  229	                        normal_tat=tat=(clock+x.page_fault_time+x.segment_fault_time+ x.clock1)-x.arrivaltime;
  230	                        mean_tat=mean_tat+normal_tat;
  231	                        normal_wt=normal_wt+(normal_tat- x.clock1 - x.segment_fault_time -
  232	                                x.page_fault_time);
  233	                        mean_wt=mean_wt+(normal_tat-x.executiontime);
  234	                        meter(x);
  235	                        meter2(x);
  236	                        normal_termination++;
  237	                        haltflag = 1;
  238	                        available_memory_size = available_memory_size + x.no_of_frames;
  239	                        count_halt++;
  240	
  241	                        // checking the jobs present in blocked queue.
  242	                        blockedcheck();
  243	                        //spooling more jobs
  244	
  245	                        break;
  246	                    }
  247	
  248	                }
  249	
  250	            }
  251	            // It catches all the exceptions thrown by all the components in the Simple Batch System.
  252	            catch (Exception e) {
  253	                if (currentjob != null) {
  254	                    abnormal_termination++;
  255	                    currentjob.departuretime=clock;
  256	                    tat=(clock+currentjob.page_fault_time+currentjob.segment_fault_time)-currentjob.arrivaltime;
  257	                    meter2(currentjob);
  258	                    suspected_infinite=suspected_infinite+currentjob.run_time-currentjob.page_fault_time-currentjob.segment_fault_time-currentjob.clock1;
  259	                    time_abnormal_termination=time_abnormal_termination+currentjob.run_time;
  260	                    available_memory_size = available_memory_size + currentjob.no_of_frames;
  261	                    error = 1;
  262	                    currentjob.termtype = "ABNORMAL";
  263	                    currentjob.warningmsg = e.toString();
  264	                    currentjob.exit_flag = 1;
  265	                    OUTPUTSPOOLING.output(currentjob);
  266	                    ready_queue.remove(job_id.get(currentjob));
  267	                    blocked_queue.remove(job_id.get(currentjob));
  268	
  269	                }
  270	            }
  271	        }
  272	        OUTPUTSPOOLING.executionprofile();
  273	
  274	    }
  275	
  276	    public static void meter(PCB p) {
  277	        if (cpu_min_time == 0) {
  278	            cpu_min_time = p.executiontime;
  279	        }
  280	        if (cpu_max_time == 0) {







2018-05-02 10:44                   SYSTEM.java                    Page 6


  281	            cpu_max_time = p.executiontime;
  282	        }
  283	        if (p.executiontime < cpu_min_time) {
  284	            cpu_min_time = p.executiontime;
  285	        }
  286	        if (p.executiontime > cpu_min_time) {
  287	            cpu_max_time = p.executiontime;
  288	        }
  289	        cpu_avg_time = (p.executiontime + cpu_avg_time) / 2.0;
  290	    }
  291	
  292	    public static void meter2(PCB p) {
  293	        if(ta_min_time==0){ta_min_time=tat;}
  294	        if(ta_max_time==0){ta_max_time=tat;}
  295	        if(tat<ta_min_time){ta_min_time=tat;}
  296	        if(tat>ta_max_time){ta_max_time=tat;}
  297	        ta_avg_time=tat+ta_avg_time/2.0;
  298	
  299	        if(code_min_batch==0){code_min_batch=p.program_segment_size;}
  300	        if(code_max_batch==0){code_max_batch=p.program_segment_size;}
  301	        if(p.program_segment_size<code_min_batch){code_min_batch=p.program_segment_size;}
  302	        if(p.program_segment_size>code_max_batch){code_max_batch=p.program_segment_size;}
  303	        code_avg_batch=code_avg_batch+p.program_segment_size/2.0;
  304	
  305	        if(input_min_batch==0){input_min_batch=p.input_segment_size;}
  306	        if(input_max_batch==0){input_max_batch=p.input_segment_size;}
  307	        if(p.input_segment_size<input_min_batch){input_min_batch=p.input_segment_size;}
  308	        if(p.input_segment_size>input_max_batch){input_max_batch=p.input_segment_size;}
  309	        input_avg_batch=input_avg_batch+p.input_segment_size/2.0;
  310	
  311	        if(input_min_loader==0){input_min_loader=p.input_size;}
  312	        if(input_max_loader==0){input_max_loader=p.input_size;}
  313	        if(p.input_size<input_min_loader){input_min_loader=p.input_size;}
  314	        if(p.input_size>input_max_loader){input_max_loader=p.input_size;}
  315	        input_avg_loader=input_avg_loader+p.input_size/2.0;
  316	
  317	
  318	        if(output_min_batch==0){output_min_batch=p.output_segment_size;}
  319	        if(output_max_batch==0){output_max_batch=p.output_segment_size;}
  320	        if(p.output_segment_size<output_min_batch){output_min_batch=p.output_segment_size;}
  321	        if(p.output_segment_size>output_max_batch){output_max_batch=p.output_segment_size;}
  322	        output_avg_batch=output_avg_batch+p.output_segment_size/2.0;
  323	
  324	
  325	        if(output_min_loader==0){output_min_loader=p.output_size;}
  326	        if(output_max_loader==0){output_max_loader=p.output_size;}
  327	        if(p.output_size<output_min_loader){output_min_loader=p.output_size;}
  328	        if(p.output_size>output_max_loader){output_max_loader=p.output_size;}
  329	        output_avg_loader=output_avg_loader+p.output_size/2.0;
  330	
  331	        if(cpushot_min==0){cpushot_min=p.cpushot;}
  332	        if(cpushot_max==0){cpushot_max=p.cpushot;}
  333	        if(p.cpushot<cpushot_min){cpushot_min=p.cpushot;}
  334	        if(p.cpushot>cpushot_max){cpushot_max=p.cpushot;}
  335	        cpushot_avg=p.cpushot+cpushot_avg/2.0;
  336	







2018-05-02 10:44                   SYSTEM.java                    Page 7


  337	        if(io_min==0){io_min=p.ioshot;}
  338	        if(io_max==0){io_max=p.ioshot;}
  339	        if(p.ioshot<io_min){io_min=p.ioshot;}
  340	        if(p.ioshot>io_max){io_max=p.ioshot;}
  341	        io_avg=p.ioshot+io_avg/2.0;
  342	
  343	
  344	    }
  345	
  346	    public static void blockedcheck() {
  347	        int mega = blocked_queue.size();
  348	        block();
  349	        while (mega > 0) {
  350	            PCB a = pcb.get(blocked_queue.poll());
  351	            if (a.blocked_status.equals("ready")) {
  352	
  353	                ready_queue.add(job_id.get(a));
  354	            } else {
  355	                blocked_queue.add(job_id.get(a));
  356	            }
  357	
  358	            mega--;
  359	        }
  360	
  361	    }
  362	
  363	    public static void block() {
  364	
  365	        int last_size = blocked_queue.size();
  366	        while (last_size > 0) {
  367	            PCB a = pcb.get(blocked_queue.poll());
  368	            if (((clock + a.page_fault_time + a.segment_fault_time) - a.blocked_time) > 20) {
  369	                a.blocked_status = "ready";
  370	            }
  371	            blocked_queue.add(job_id.get(a));
  372	            last_size--;
  373	        }
  374	    }
  375	
  376	    public static void Inputspooling(BufferedReader bufferedReader) throws ERROR_HANDLER, IOException {
  377	
  378	
  379	        PCB a;
  380	        String[] word = new String[8];
  381	        int size;
  382	        String firstline;
  383	        while (true) {
  384	            try {
  385	                firstline = bufferedReader.readLine();
  386	                count_inputfile++;
  387	                if (firstline != null) {
  388	                    String[] frstline;
  389	                    frstline = firstline.split(" ");
  390	
  391	
  392	                    jid = jid + 1;







2018-05-02 10:44                   SYSTEM.java                    Page 8


  393	                    a = aa[jid] = new PCB();
  394	                    pcb.put(jid, aa[jid]);
  395	                    job_id.put(a, jid);
  396	                    a.job_id = jid;
  397	                    currentjob2 = a;
  398	                    a.internal_jid=jid;
  399	                    if (frstline.length != 3) {
  400	
  401	                        //if the first line of job is not defined properly it throws an error
  402	                        throw new ERROR_HANDLER(7);
  403	                    }
  404	
  405	                    //checks for**JOB- Input spooling starts here
  406	                    if (!frstline[0].equals("**JOB")) {
  407	
  408	                        //if the first line of job is not defined properly it throws an error
  409	                        throw new ERROR_HANDLER(6);
  410	                    }
  411	
  412	
  413	                    a.input_segment_size = Integer.parseInt(Hextoany.hexTodecimal(frstline[1]));
  414	                    a.output_segment_size = Integer.parseInt(Hextoany.hexTodecimal(frstline[2]));
  415	                    count_inputfile++;
  416	                    firstline = bufferedReader.readLine();
  417	                    frstline = firstline.split(" ");
  418	                    if (frstline.length != 5) {
  419	                        //if the first line of job is not defined properly it throws an error
  420	
  421	                        throw new ERROR_HANDLER(19);
  422	                    }
  423	                    a.program_segment_size = Integer.parseInt(Hextoany.hexTodecimal(frstline[3]));
  424	
  425	                    // TODO add jid to ready queue
  426	
  427	                    a.given_id=Integer.parseInt(Hextoany.hexTodecimal(frstline[0]));
  428	                    a.br = (Hextoany.hexTodecimal(frstline[1]));
  429	                    //if br exceeds it's limit it throws an error to the ERROR_HANDLER class
  430	                    if (Integer.parseInt(a.br) > 255) {
  431	                        throw new ERROR_HANDLER(1);
  432	                    }
  433	                    a.pc_old = a.pc = Integer.parseInt(Hextoany.hexTodecimal(frstline[2]));
  434	                    //if objpc exceeds it's limit it throws an error to the ERROR_HANDLER class
  435	                    if ((a.pc) > 127) {
  436	                        throw new ERROR_HANDLER(2);
  437	                    }
  438	
  439	                    size = a.program_segment_size;
  440	                    if (frstline[4].equals("0") || frstline[4].equals("1")) {
  441	                        a.trace_flag = Hextoany.hexTodecimal(frstline[4]);
  442	                    } else {
  443	                        a.trace_flag = "0";
  444	                        a.warningmsg = "trace flag warning";
  445	                        a.termtype = "Normal";
  446	                    }
  447	                    //if Trace_flag has improper decleration it throws an error to the ERROR_HANDLER class
  448	







2018-05-02 10:44                   SYSTEM.java                    Page 9


  449	                    //put no of required program pages in pages present in pcb.
  450	                    a.pages.put("program_page_size", (int) Math.ceil((a.program_segment_size / 8.0)));
  451	                    //put no of required input.txt pages in pages present in pcb.
  452	                    a.pages.put("input_page_size", (int) Math.ceil((a.input_segment_size / 8.0)));
  453	                    //put no of required output pages in pages present in pcb.
  454	                    a.pages.put("output_page_size", (int) Math.ceil((a.output_segment_size / 8.0)));
  455	                    // total pages required for the job
  456	
  457	                    String line, line1, input;
  458	                    int program_page = a.pages.get("program_page_size");
  459	                    int input_page = a.pages.get("input_page_size");
  460	                    int input_words = a.input_segment_size;
  461	                    int output_page = a.pages.get("output_page_size");
  462	                    int count_program = 0;
  463	                    a.total_pages = a.pages.get("program_page_size") + a.pages.get("input_page_size") +
  464	                            a.pages.get("output_page_size");
  465	                    if (available_memory_size < a.total_pages) {
  466	                        jid = jid - 1;
  467	                        break;
  468	                    }
  469	                    a.totpage = a.no_of_frames = Math.min(6, a.total_pages);
  470	
  471	                    available_memory_size = available_memory_size - a.no_of_frames;
  472	                    a.arrivaltime=clock;
  473	                    ready_queue.add(jid);
  474	
  475	                    if (a.trace_flag.equals("1")) {
  476	                        a.pw = new PrintWriter(new FileWriter(System.getProperty("user.dir") + "/tracefile_" + a.given_id+"_"+jid+".txt"));
  477	                    }
  478	                    if (a.trace_flag.equals("1")) {
  479	                        a.pw.println(String.format(
  480	                                "%30s%17s%10s%15s\r\n", "", "Before  execution", "",
  481	                                "After  execution"));
  482	                        a.pw.println(String.format(
  483	                                "%7s%8s%6s%8s%7s%7s%7s%7s%7s%7s%7s\r\n", "HEX",
  484	                                "HEX", "HEX", "HEX", " HEX", "HEX", " HEX",
  485	                                "HEX", " HEX", "HEX", " HEX"));
  486	                        a.pw.println(String.format(
  487	                                "%7s%8s%6s%8s%7s%7s%7s%7s%7s%7s%7s\r\n", "PC",
  488	                                "BR", "IR", "TOS", "S[TOS]", "EA", "(EA)",
  489	                                "TOS", "S[TOS]", "EA", "(EA)"));
  490	                    }
  491	                    //min number of frames allocated to a job
  492	                    //double x=Math.ceil(size/4.0);
  493	                    //count_inputfile= (int) (count_inputfile+x);
  494	                    //reading the program segment from the input.txt job
  495	                    while (size > 0 && (line = bufferedReader.readLine()) != null) {
  496	                        count_inputfile++;
  497	                        int l = 0;
  498	                        char[] ch = line.toCharArray();
  499	                        for (int k = 0; k < 8; k++) {
  500	
  501	                            word[k] = "";
  502	                        }
  503	                        for (int i = 0; i < 4; i++) {
  504	                            count_program++;







2018-05-02 10:44                   SYSTEM.java                   Page 10


  505	                            for (int j = l; j < l + 4 && j < ch.length; j++) {
  506	
  507	                                word[i] = word[i] + ch[j];
  508	
  509	                            }
  510	                            if ((a.program_segment_size >= count_program) && word[i].equals("")) {
  511	                                throw new ERROR_HANDLER(18);
  512	                            }
  513	                            if ((a.program_segment_size < count_program) && !("").equals(String.valueOf(word[i]))) {
  514	                                throw new ERROR_HANDLER(18);
  515	                            }
  516	
  517	                            l = l + 4;
  518	
  519	                        }
  520	                        size = size - 4;
  521	                        if (size > 0) {
  522	                            line1 = bufferedReader.readLine();
  523	                            count_inputfile++;
  524	                            if ((line1 != null) && (!("**INPUT").equals(line1))) {
  525	                                int l1 = 0;
  526	                                char[] ch1 = line1.toCharArray();
  527	                                for (int i = 4; i < 8; i++) {
  528	                                    count_program++;
  529	                                    for (int j = l1; j < l1 + 4 && j < ch1.length; j++) {
  530	
  531	                                        word[i] = word[i] + ch1[j];
  532	
  533	                                    }
  534	
  535	                                    if ((a.program_segment_size >= count_program) && word[i].equals("")) {
  536	                                        throw new ERROR_HANDLER(18);
  537	                                    }
  538	                                    if ((a.program_segment_size < count_program) && !("").equals(String.valueOf
  539	                                            (word[i]))) {
  540	                                        throw new ERROR_HANDLER(18);
  541	                                    }
  542	                                    l1 = l1 + 4;
  543	                                }
  544	                                size = size - 4;
  545	                            } else {
  546	                                throw new ERROR_HANDLER(18);
  547	                            }
  548	                        }
  549	                        // loops disk frame vector to get the available page in disk
  550	                        int d = 0;
  551	                        for (int i = 0; i < fmbv_disk.length; i++) {
  552	                            if (fmbv_disk[i] == 0 && program_page > 0) {
  553	                                if (a.program_flag == 0) {
  554	                                    a.segment_index.put("program_segment_pointer", i * 8);
  555	                                    a.program_flag = 1;
  556	                                }
  557	                                fmbv_disk[i] = 1;
  558	                                memoryaddress = i * 8;
  559	                                a.frame_disk.add(memoryaddress);
  560	                                a.disk_page_count++;







2018-05-02 10:44                   SYSTEM.java                   Page 11


  561	                                a.disk_map.put(a.disk_page_count, memoryaddress);
  562	                                program_page--;
  563	                                break;
  564	                            }
  565	                        }
  566	                        //copy the pages from input.txt file to the disk.
  567	                        for (int i = 0; i < word.length && (word[i] != null); i++) {
  568	                            if (word[i].equals("")) {
  569	                                word[i] = "0000";
  570	                                a.disk_fragment_size++;
  571	                            }
  572	
  573	                            DISK.disk_fun("write", Integer.toString(memoryaddress), word[i]);
  574	                            memoryaddress++;
  575	                        }
  576	
  577	
  578	                    }
  579	
  580	                    //Copying the input.txt data segment from the job to the disk by checking the available frame
  581	                    input = bufferedReader.readLine();
  582	                    count_inputfile++;
  583	                    if (input.equals("**INPUT")) {
  584	                        String[] word1 = new String[8];
  585	                        for (int k = 0; k < 8; k++) {
  586	
  587	                            word1[k] = "";
  588	                        }
  589	                        int word_count = 0;
  590	                        int cc = 0;
  591	                        while (input_words > 0 && (input = bufferedReader.readLine()) != null) {
  592	                            if (cc == 8) {
  593	                                word_count = 0;
  594	                                for (int k = 0; k < 8; k++) {
  595	                                    word1[k] = "";
  596	                                }
  597	                            }
  598	                            count_inputfile++;
  599	                            if (input.equals("**INPUT")) {
  600	                                throw new ERROR_HANDLER(20);
  601	                            }
  602	                            if (input.equals("**FIN")) {
  603	                                throw new ERROR_HANDLER(17);
  604	                            }
  605	
  606	                            int joblength = input.length();
  607	                            int count_line = 0;
  608	                            while (joblength > 0) {
  609	                                try {
  610	                                    word1[word_count] = input.substring(count_line, count_line + 4);
  611	                                } catch (Exception e) {
  612	                                    throw new ERROR_HANDLER(17);
  613	                                }
  614	                                joblength = joblength - 4;
  615	                                count_line = count_line + 4;
  616	                                word_count++;







2018-05-02 10:44                   SYSTEM.java                   Page 12


  617	                                input_words--;
  618	                                cc++;
  619	
  620	                            }
  621	                            if (word_count == 8 || input_words == 0) {
  622	                                int d = 0;
  623	                                //checking the available disk frame to spool the input.txt data segment
  624	                                for (int i = 0; i < fmbv_disk.length; i++) {
  625	                                    if (fmbv_disk[i] == 0 && input_page > 0) {
  626	                                        if (a.input_flag == 0) {
  627	                                            a.input_flag = 1;
  628	                                            a.segment_index.put("input_segment_pointer", i * 8);
  629	                                        }
  630	                                        fmbv_disk[i] = 1;
  631	                                        memoryaddress = i * 8;
  632	                                        a.frame_disk.add(memoryaddress);
  633	                                        a.disk_page_count++;
  634	                                        a.disk_map.put(a.disk_page_count, memoryaddress);
  635	                                        input_page--;
  636	                                        break;
  637	                                    }
  638	                                }
  639	
  640	
  641	                                // copy input.txt program segment to disk
  642	                                for (int i = 0; i < 8; i++) {
  643	                                    if (word1[i].equals("")) {
  644	
  645	                                        a.disk_fragment_size++;
  646	                                    }
  647	                                    if (!word1[i].equals("")) {
  648	                                        a.input.add(word1[i]);
  649	                                    }
  650	                                    a.input_size++;
  651	                                    DISK.disk_fun("write", Integer.toString(memoryaddress), word1[i]);
  652	                                    memoryaddress++;
  653	                                }
  654	
  655	                                for (int k = 0; k < 8; k++) {
  656	
  657	                                    word1[k] = "";
  658	                                }
  659	                                word_count = 0;
  660	                            }
  661	
  662	                        }
  663	
  664	                    } else {
  665	                        throw new ERROR_HANDLER(4);
  666	                    }
  667	
  668	
  669	                    //allocate space for output program segment
  670	
  671	                    while (output_page > 0) {
  672	                        for (int i = 0; i < fmbv_disk.length; i++) {







2018-05-02 10:44                   SYSTEM.java                   Page 13


  673	                            if (fmbv_disk[i] == 0) {
  674	                                if (a.output_flag == 0) {
  675	                                    a.output_flag = 1;
  676	                                    a.segment_index.put("output_segment_pointer", i * 8);
  677	                                }
  678	                                fmbv_disk[i] = 1;
  679	                                memoryaddress = i * 8;
  680	                                a.frame_disk.add(memoryaddress);
  681	                                a.disk_page_count++;
  682	                                a.disk_map.put(a.disk_page_count, memoryaddress);
  683	                                output_page--;
  684	                                break;
  685	                            }
  686	
  687	                        }
  688	                        for (int i = 0; i < 8; i++) {
  689	                            a.output_size++;
  690	                            a.disk_fragment_size++;
  691	                            DISK.disk_fun("write", Integer.toString(memoryaddress), "");
  692	                            memoryaddress++;
  693	                        }
  694	                    }
  695	
  696	                    input = bufferedReader.readLine();
  697	                    count_inputfile++;
  698	                    if (input.equals("**INPUT")) {
  699	                        throw new ERROR_HANDLER(20);
  700	                    }
  701	                    //end of file
  702	                    if (!("**FIN").equals(input)) {
  703	                        throw new ERROR_HANDLER(5);
  704	                    }
  705	
  706	                } else {
  707	                    finale = 1;
  708	                    count_inputfile--;
  709	                    break;
  710	
  711	                }
  712	
  713	            }
  714	            // It catches all the exceptions thrown by all the components in the Simple Batch System.
  715	
  716	            catch (Exception e) {
  717	                tat=(clock+currentjob2.page_fault_time+currentjob2.segment_fault_time)-currentjob2.arrivaltime;
  718	                meter2(currentjob2);
  719	                abnormal_termination++;
  720	                currentjob2.departuretime=clock;
  721	                suspected_infinite=suspected_infinite+currentjob2.run_time-currentjob2.page_fault_time-currentjob2.segment_fault_time-currentjob2.clock1;
  722	                time_abnormal_termination=time_abnormal_termination+currentjob2.run_time;
  723	                available_memory_size = available_memory_size + currentjob2.no_of_frames;
  724	
  725	                currentjob2.termtype = "ABNORMAL";
  726	                currentjob2.warningmsg = e.toString();
  727	                currentjob2.exit_flag = 1;
  728	                OUTPUTSPOOLING.output(currentjob2);







2018-05-02 10:44                   SYSTEM.java                   Page 14


  729	                while (true) {
  730	                    count_inputfile++;
  731	                    firstline = bufferedReader.readLine();
  732	                    if (firstline.equals("**FIN") || firstline == null) {
  733	                        break;
  734	
  735	                    }
  736	                }
  737	                ready_queue.remove(jid);
  738	
  739	            }
  740	
  741	        }
  742	
  743	
  744	    }
  745	
  746	}
  747	










































bash-4.4$ java SYSTEM /home/opsys/SPR18/tb
bash-4.4$ cat -n Execution_profile.txt | head -40
     1	
     2	-----------------------------------------
     3	
     4	 -----------------------SNAPSHOT---------------
     5	
     6	CONTENTS OF READY QUEUE         (DEC): 4,1,5,
     7	JOB ID CURRENTLY EXECUTING      (DEC): 3
     8	PMT  
     9	Page number  frame number
    10	    0      -     12
    11	    7      -     13
    12	    5      -     14
    13	
    14	CONTENTS OF BLOCKED QUEUE       (DEC): 2,
    15	DEGREE OF MULTIPROGRAMMING      (DEC): 4
    16	MEMORY UTILIZATION              (DEC): 80.86%
    17	DISK UTILIZATION                (DEC): 12.45%
    18	----------------------------------------------
    19	
    20	-----------------------------------------
    21	
    22	 -----------------------SNAPSHOT---------------
    23	
    24	CONTENTS OF READY QUEUE         (DEC): 4,5,1,
    25	JOB ID CURRENTLY EXECUTING      (DEC): 2
    26	PMT  
    27	Page number  frame number
    28	    0      -     6
    29	    6      -     7
    30	    5      -     8
    31	    4      -     9
    32	    1      -     10
    33	
    34	CONTENTS OF BLOCKED QUEUE       (DEC): 3,
    35	DEGREE OF MULTIPROGRAMMING      (DEC): 4
    36	MEMORY UTILIZATION              (DEC): 80.86%
    37	DISK UTILIZATION                (DEC): 12.45%
    38	----------------------------------------------
    39	
    40	-----------------------------------------
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -3000 | head -40
  4130	
  4131	CONTENTS OF READY QUEUE         (DEC): 62,63,61,
  4132	JOB ID CURRENTLY EXECUTING      (DEC): 52
  4133	PMT  
  4134	Page number  frame number
  4135	    0      -     5
  4136	    3      -     24
  4137	    2      -     25
  4138	    1      -     26
  4139	    4      -     27
  4140	    5      -     28
  4141	
  4142	CONTENTS OF BLOCKED QUEUE       (DEC): 64,
  4143	DEGREE OF MULTIPROGRAMMING      (DEC): 4
  4144	MEMORY UTILIZATION              (DEC): 76.56%
  4145	DISK UTILIZATION                (DEC): 7.67%
  4146	----------------------------------------------
  4147	
  4148	
  4149	
  4150	
  4151	JOB ID : 52  (HEX)
  4152	INPUT SEGMENT DATA FOR JOB 52 (HEX) : FFFE,0001,000A,
  4153	OUTPUT SEGMENT DATA FOR JOB 52(BIN) : 0000000000000000,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,0000000000000001,
  4154	CLOCK              : 6d8b  (HEX)28043
  4155	ARRIVAL TIME       : 23391 (DEC)
  4156	DEPARTURE TIME       : 0 (DEC)
  4157	JOB RUN TIME       : 1311 (DEC)
  4158	EXECUTION TIME     : 926 (DEC)
  4159	INPUT/OUTPUT TIME  : 255  (DEC)
  4160	NO OF PAGEFAULTS  : 6  (DEC)
  4161	NO OF SEGMENT FAULTS  : 2  (DEC)
  4162	SEGMENT FAULT TIME : 10  (DEC)
  4163	PAGE FAULT TIME    : 120  (DEC)
  4164	MEMORY UTILIZATION IN WORDS : RATIO  : 43/256 PERCENTAGE  : 16.80 %
  4165	MEMORY UTILIZATION IN FRAMES : RATIO : 3/16 PERCENTAGE    : 18.75 %
  4166	DISK UTILIZATION IN WORDS :   RATIO  : 43/2048 PERCENTAGE : 2.10 %
  4167	DISK UTILIZATION IN FRAMES :   RATIO : 3/128 PERCENTAGE  : 2.34 %
  4168	MEMORY FRAGMENT SIZE : 5  (DEC)
  4169	DISK FRAGMENT SIZE   : 1.6666666666666667  (DEC)
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -1400 | head -40
  5730	 -----------------------SNAPSHOT---------------
  5731	
  5732	CONTENTS OF READY QUEUE         (DEC): 84,88,90,
  5733	JOB ID CURRENTLY EXECUTING      (DEC): 81
  5734	PMT  
  5735	Page number  frame number
  5736	    0      -     15
  5737	    3      -     16
  5738	    2      -     22
  5739	    1      -     23
  5740	    4      -     24
  5741	    5      -     25
  5742	
  5743	CONTENTS OF BLOCKED QUEUE       (DEC): 89,
  5744	DEGREE OF MULTIPROGRAMMING      (DEC): 4
  5745	MEMORY UTILIZATION              (DEC): 62.50%
  5746	DISK UTILIZATION                (DEC): 11.91%
  5747	----------------------------------------------
  5748	
  5749	-----------------------------------------
  5750	
  5751	 -----------------------SNAPSHOT---------------
  5752	
  5753	CONTENTS OF READY QUEUE         (DEC): 90,89,81,88,
  5754	JOB ID CURRENTLY EXECUTING      (DEC): 84
  5755	PMT  
  5756	Page number  frame number
  5757	    8      -     5
  5758	    0      -     6
  5759	    12      -     7
  5760	    9      -     8
  5761	    7      -     9
  5762	    10      -     10
  5763	
  5764	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
  5765	DEGREE OF MULTIPROGRAMMING      (DEC): 4
  5766	MEMORY UTILIZATION              (DEC): 79.69%
  5767	DISK UTILIZATION                (DEC): 11.91%
  5768	----------------------------------------------
  5769	
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -600 | head -40
  6530	JOB ID CURRENTLY EXECUTING      (DEC): 89
  6531	PMT  
  6532	Page number  frame number
  6533	    6      -     0
  6534	    0      -     1
  6535	    3      -     2
  6536	    2      -     3
  6537	    4      -     4
  6538	    1      -     28
  6539	
  6540	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
  6541	DEGREE OF MULTIPROGRAMMING      (DEC): 4
  6542	MEMORY UTILIZATION              (DEC): 91.02%
  6543	DISK UTILIZATION                (DEC): 13.77%
  6544	----------------------------------------------
  6545	
  6546	-----------------------------------------
  6547	
  6548	 -----------------------SNAPSHOT---------------
  6549	
  6550	CONTENTS OF READY QUEUE         (DEC): 99,102,89,
  6551	JOB ID CURRENTLY EXECUTING      (DEC): 101
  6552	PMT  
  6553	Page number  frame number
  6554	    3      -     11
  6555	    5      -     12
  6556	    4      -     13
  6557	
  6558	CONTENTS OF BLOCKED QUEUE       (DEC): 97,
  6559	DEGREE OF MULTIPROGRAMMING      (DEC): 4
  6560	MEMORY UTILIZATION              (DEC): 86.33%
  6561	DISK UTILIZATION                (DEC): 13.77%
  6562	----------------------------------------------
  6563	
  6564	-----------------------------------------
  6565	
  6566	 -----------------------SNAPSHOT---------------
  6567	
  6568	CONTENTS OF READY QUEUE         (DEC): 102,101,97,
  6569	JOB ID CURRENTLY EXECUTING      (DEC): 89
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -200 | head -40
  6930	
  6931	
  6932	JOB ID : 103  (HEX)
  6933	INPUT SEGMENT DATA FOR JOB 103 (HEX) : 0002,0123,02FF,
  6934	OUTPUT SEGMENT DATA FOR JOB 103(BIN) : 0000001011111111,0000000100100011,
  6935	CLOCK              : b481  (HEX)46209
  6936	ARRIVAL TIME       : 44878 (DEC)
  6937	DEPARTURE TIME       : 0 (DEC)
  6938	JOB RUN TIME       : 379 (DEC)
  6939	EXECUTION TIME     : 114 (DEC)
  6940	INPUT/OUTPUT TIME  : 75  (DEC)
  6941	NO OF PAGEFAULTS  : 9  (DEC)
  6942	NO OF SEGMENT FAULTS  : 2  (DEC)
  6943	SEGMENT FAULT TIME : 10  (DEC)
  6944	PAGE FAULT TIME    : 180  (DEC)
  6945	MEMORY UTILIZATION IN WORDS : RATIO  : 21/128 PERCENTAGE  : 16.41 %
  6946	MEMORY UTILIZATION IN FRAMES : RATIO : 3/16 PERCENTAGE    : 18.75 %
  6947	DISK UTILIZATION IN WORDS :   RATIO  : 57/2048 PERCENTAGE : 2.78 %
  6948	DISK UTILIZATION IN FRAMES :   RATIO : 9/256 PERCENTAGE  : 3.52 %
  6949	MEMORY FRAGMENT SIZE : 6  (DEC)
  6950	DISK FRAGMENT SIZE   : 5.0  (DEC)
  6951	TURN AROUND TIME : 44803  (DEC)
  6952	
  6953	
  6954	
  6955	
  6956	JOB ID : 105  (HEX)
  6957	INPUT SEGMENT DATA FOR JOB 105 (HEX) : 0017,0013,0002,0001,0006,
  6958	OUTPUT SEGMENT DATA FOR JOB 105(BIN) : 0000000000000010,0000000000010011,0000000000010111,
  6959	CLOCK              : b484  (HEX)46212
  6960	ARRIVAL TIME       : 45040 (DEC)
  6961	DEPARTURE TIME       : 0 (DEC)
  6962	JOB RUN TIME       : 354 (DEC)
  6963	EXECUTION TIME     : 94 (DEC)
  6964	INPUT/OUTPUT TIME  : 90  (DEC)
  6965	NO OF PAGEFAULTS  : 8  (DEC)
  6966	NO OF SEGMENT FAULTS  : 2  (DEC)
  6967	SEGMENT FAULT TIME : 10  (DEC)
  6968	PAGE FAULT TIME    : 160  (DEC)
  6969	MEMORY UTILIZATION IN WORDS : RATIO  : 43/256 PERCENTAGE  : 16.80 %
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -40
  7090	CPU SHOTS 
  7091	---MINIMUM       (DEC): 18 
  7092	---MAXIMUM       (DEC): 96 
  7093	---AVERAGE       (DEC): 81.02 
  7094	
  7095	I/0 REQUESTS 
  7096	---MINIMUM       (DEC): 9 
  7097	---MAXIMUM       (DEC): 22 
  7098	---AVERAGE       (DEC): 31.17 
  7099	----------------------------------------------------------
  7100	-----------------------------------------------------------
  7101	
  7102	JOBS THAT TERMINATED NORMALLY (DEC): 99 
  7103	
  7104	
  7105	JOBS THAT TERMINATED ABNORMALLY (DEC): 6 
  7106	
  7107	
  7108	TIME LOST DUE TO ABNORMAL TERMINATION OF JOBS :0 
  7109	
  7110	
  7111	TIME LOST DUE SUSPECTED INFINITE JOBS (DEC):0 (DEC)
  7112	
  7113	
  7114	ID'S OF JOBS SUSPECTED INFINITE (DEC):
  7115	
  7116	
  7117	MEAN TURN AROUND TIME OF JOBS THAT TERMINATED NORMALLY (DEC): 2366.79 
  7118	
  7119	
  7120	MEAN WAITING TIME OF JOBS THAT TERMINATED NORMALLY (DEC): 2089.05 
  7121	
  7122	
  7123	MEAN NUMBER OF PAGEFAULTS (DEC): 9.00 
  7124	
  7125	
  7126	MEAN MEMORY UTILIZATION OVER ALL SAMPLING INTERVALS (DEC): 74.00% 
  7127	
  7128	
  7129	MEAN DISK UTILIZATION OVER ALL SAMPLING INTERVALS (DEC): 11.00 %
bash-4.4$ echo "==================================================="
===================================================
bash-4.4$ cat -n tracefile_1_4.txt | head -20
     1	                              Before  execution          After  execution
     2	
     3	    HEX     HEX   HEX     HEX    HEX    HEX    HEX    HEX    HEX    HEX    HEX
     4	
     5	     PC      BR    IR     TOS S[TOS]     EA   (EA)    TOS S[TOS]     EA   (EA)
     6	
     7	      0      0      0      0      0      0      0      0      0      0      0
     8	      1      0     13      0      0      0      0      1      2      0      0
     9	      2      0     13      1      2      0      0      2     10      0      0
    10	      3      0      d      2     10      0      0      3      1      0      0
    11	      4      0   c028      3      1      0      0      2     10     28      0
    12	     28      0   dc22      2     10     22   c02d      1      2     22   c02d
    13	     29      0   bc08      1      2     22   c02d      1      2      8      4
    14	      8      0     13      1      2      8      0      2     28      8      4
    15	      9      0      d      2     28      8      0      3      1      8      4
    16	      a      0   c02d      3      1      8      4      2     28     2d      0
    17	     2d      0   dc20      2     28     2d      0      1      2     20     13
    18	     2e      0   dc1e      1      2     1e      0      0      0     1e      0
    19	     2f      0   bc0d      0      0     1e      0      0      0      d      0
    20	      d      0   d820      0      0      d      0      1     28     20     13
bash-4.4$ echo "-----------------------------------------"
-----------------------------------------
bash-4.4$ cat -n tracefile_1_4.txt | tail -20
    13	     29      0   bc08      1      2     22   c02d      1      2      8      4
    14	      8      0     13      1      2      8      0      2     28      8      4
    15	      9      0      d      2     28      8      0      3      1      8      4
    16	      a      0   c02d      3      1      8      4      2     28     2d      0
    17	     2d      0   dc20      2     28     2d      0      1      2     20     13
    18	     2e      0   dc1e      1      2     1e      0      0      0     1e      0
    19	     2f      0   bc0d      0      0     1e      0      0      0      d      0
    20	      d      0   d820      0      0      d      0      1     28     20     13
    21	      e      0   d822      1     28     20     13      2     10     22   c02d
    22	      f      0      d      2     10     22      0      3      0     22   c02d
    23	     10      0   c032      3      0     22   c02d      2     10     32   a425
    24	     11      0   dc20      2     10     32   a425      1     28     20     13
    25	     12      0   dc22      1     28     20     13      0      0     22   c02d
    26	     13      0   d822      0      0     22   c02d      1     28     22   c02d
    27	     14      0   d820      1     28     22   c02d      2     10     20     13
    28	     15      0   d81e      2     10     1e      0      3      2     1e      0
    29	     16      0     14      3      2     1e      0      2     10     1e      0
    30	     17      0     14      2     10     1e      0      1     28     1e      0
    31	     18      0     14      1     28     1e      0      0      0     1e      0
    32	     19      0     18      0      0     1e      0bash-4.4$ echo "==================================================="
===================================================
bash-4.4$ echo "==================================================="
===================================================
bash-4.4$ cat -n tracefile_1_26.txt | head -20
     1	                              Before  execution          After  execution
     2	
     3	    HEX     HEX   HEX     HEX    HEX    HEX    HEX    HEX    HEX    HEX    HEX
     4	
     5	     PC      BR    IR     TOS S[TOS]     EA   (EA)    TOS S[TOS]     EA   (EA)
     6	
     7	      a      0     13      0      0      0      0      1     14      0      0
     8	      b      0   dc01      1     14      1      1      0      0      1      1
     9	      c      0     13      0      0      1      0      1      0      1      1
    10	      d      0   dc02      1      0      1      1      0      0      2     13
    11	      e      0     13      0      0      2      0      1      1      2     13
    12	      f      0   dc03      1      1      2     13      0      0      3   dc01
    13	     10      0     13      0      0      3      0      1      2      3   dc01
    14	     11      0   dc04      1      2      3   dc01      0      0      4     13
    15	     12      0     13      0      0      4      0      1    e1e      4     13
    16	     13      0   dc05      1    e1e      4     13      0      0      5   dc02
    17	     14      0   d800      0      0      5   dc02      1      1      0      0
    18	     15      0   d801      1      1      0      0      2     14      1      1
    19	     16      0   d802      2     14      1      1      3      0      2     13
    20	     17      0      c      3      0      2      0      4      1      2     13
bash-4.4$ echo "-----------------------------------------"
-----------------------------------------
bash-4.4$ cat -n tracefile_1_26.txt | tail -20
   169	     29      0      c      3    e1e      5      0      4      0      5   9409
   170	     2a      0   c04c      4      0      5   9409      3    e1e     4c     14
   171	     2b      0   dc05      3    e1e     4c     14      2     14      5   9409
   172	     2c      0   dc04      2     14      5   9409      1     10      4   dc04
   173	     2d      0   9409      1     10      9     10      1     20      9     10
   174	     2e      0   dc09      1     20      9     10      0      0      9     20
   175	     2f      0   d809      0      0      9     20      1     20      9     20
   176	     30      0   b006      1     20      9     20      2      1      6   dc09
   177	     31      0   c415      2      1      6   dc09      1     20     15    e1e
   178	     32      0   d805      1     20     15    e1e      2    e1e      5   9409
   179	     33      0   d804      2    e1e      5   9409      3     14      4   dc04
   180	     34      0   d803      3     14      4   dc04      4      2      3   dc05
   181	     35      0   d802      4      2      3   dc05      5      1      2   c04c
   182	     36      0   d801      5      1      2   c04c      6      0      1      c
   183	     37      0     14      6      0      1      0      5      1      1      c
   184	     38      0     14      5      1      1      0      4      2      1      c
   185	     39      0     14      4      2      1      0      3     14      1      c
   186	     3a      0     14      3     14      1      0      2    e1e      1      c
   187	     3b      0     14      2    e1e      1      0      1     20      1      c
   188	     3c      0     18      1     20      1      0bash-4.4$ echo "==================================================="
===================================================
bash-4.4$ echo "==================================================="
===================================================
bash-4.4$ cat -n tracefile_1_34.txt | head -20
     1	                              Before  execution          After  execution
     2	
     3	    HEX     HEX   HEX     HEX    HEX    HEX    HEX    HEX    HEX    HEX    HEX
     4	
     5	     PC      BR    IR     TOS S[TOS]     EA   (EA)    TOS S[TOS]     EA   (EA)
     6	
     7	      0      0     13      0      0      0      0      1     13      0     13
     8	      1      0   dc12      1     13     12      0      0      0     12     13
     9	      2      0   d816      0      0     12     13      1     10     16     10
    10	      3      0   b813      1     10     16     10      2      0     13      0
    11	      4      0   c011      2      0     13      0      1     10     11     18
    12	      5      0   9814      1     10     11     18      1      f     14      1
    13	      6      0   dc16      1      f     14      1      0      0     16      f
    14	      7      0   d812      0      0     16      f      1     13     12     13
    15	      8      0   a415      1     13     12     13      1      1     15      2
    16	      9      0   dc17      1      1     15      2      0      0     17      1
    17	      a      0   d817      0      0     17      1      1      1     17      1
    18	      b      0   9c17      1      1     17      1      1      1     17      1
    19	      c      0     14      1      1     17      0      0      0     17      1
    20	      d      0   d812      0      0     17      1      1     13     12     13
bash-4.4$ echo "-----------------------------------------"
-----------------------------------------
bash-4.4$ cat -n tracefile_1_34.txt | tail -20
   233	     10      0   bc02      0      0     12      0      0      0      2   d816
   234	      2      0   d816      0      0      2   d816      1      1     16      1
   235	      3      0   b813      1      1     16      1      2      0     13      0
   236	      4      0   c011      2      0     13      0      1      1     11     18
   237	      5      0   9814      1      1     11     18      1      0     14      1
   238	      6      0   dc16      1      0     14      1      0      0     16      0
   239	      7      0   d812      0      0     16      0      1      0     12      0
   240	      8      0   a415      1      0     12      0      1      0     15      2
   241	      9      0   dc17      1      0     15      2      0      0     17      0
   242	      a      0   d817      0      0     17      0      1      0     17      0
   243	      b      0   9c17      1      0     17      0      1      0     17      0
   244	      c      0     14      1      0     17      0      0      0     17      0
   245	      d      0   d812      0      0     17      0      1      0     12      0
   246	      e      0      b      1      0     12      0      1      0     12      0
   247	      f      0   dc12      1      0     12      0      0      0     12      0
   248	     10      0   bc02      0      0     12      0      0      0      2   d816
   249	      2      0   d816      0      0      2   d816      1      0     16      0
   250	      3      0   b813      1      0     16      0      2      1     13      0
   251	      4      0   c011      2      1     13      0      1      0     11     18
   252	     11      0     18      1      0     11      0bash-4.4$ echo "==================================================="
===================================================
bash-4.4$ echo "==================================================="
===================================================
bash-4.4$ cat -n tracefile_1_81.txt | head -20
     1	                              Before  execution          After  execution
     2	
     3	    HEX     HEX   HEX     HEX    HEX    HEX    HEX    HEX    HEX    HEX    HEX
     4	
     5	     PC      BR    IR     TOS S[TOS]     EA   (EA)    TOS S[TOS]     EA   (EA)
     6	
     7	      0      0     13      0      0      0      0      1     12      0      0
     8	      1      0   dc12      1     12     12      0      0      0     12      0
     9	      2      0   d816      0      0     12      0      1     10     16      0
    10	      3      0   b813      1     10     16      0      2      0     13      0
    11	      4      0   c011      2      0     13      0      1     10     11      0
    12	      5      0   9814      1     10     11      0      1      f     14      0
    13	      6      0   dc16      1      f     14      0      0      0     16      0
    14	      7      0   d812      0      0     16      0      1     12     12      0
    15	      8      0   a415      1     12     12      0      1      0     15      0
    16	      9      0   dc17      1      0     15      0      0      0     17      0
    17	      a      0   d817      0      0     17      0      1      0     17      0
    18	      b      0   9c17      1      0     17      0      1      0     17      0
    19	      c      0     14      1      0     17      0      0      0     17      0
    20	      d      0   d812      0      0     17      0      1     12     12     1f
bash-4.4$ echo "-----------------------------------------"
-----------------------------------------
bash-4.4$ cat -n tracefile_1_81.txt | tail -20
   233	     10      0   bc02      0      0     12     15      0      0      2   d81c
   234	      2      0   d816      0      0      2   d81c      1      1     16      2
   235	      3      0   b813      1      1     16      2      2      0     13      0
   236	      4      0   c011      2      0     13      0      1      1     11   dc1b
   237	      5      0   9814      1      1     11   dc1b      1      0     14      9
   238	      6      0   dc16      1      0     14      9      0      0     16      2
   239	      7      0   d812      0      0     16      2      1      0     12     15
   240	      8      0   a415      1      0     12     15      1      0     15      9
   241	      9      0   dc17      1      0     15      9      0      0     17      0
   242	      a      0   d817      0      0     17      0      1      0     17      0
   243	      b      0   9c17      1      0     17      0      1      0     17      0
   244	      c      0     14      1      0     17      0      0      0     17      0
   245	      d      0   d812      0      0     17      0      1      0     12     15
   246	      e      0      b      1      0     12      0      1      0     12     15
   247	      f      0   dc12      1      0     12     15      0      0     12     15
   248	     10      0   bc02      0      0     12     15      0      0      2   d81c
   249	      2      0   d816      0      0      2   d81c      1      0     16      2
   250	      3      0   b813      1      0     16      2      2      1     13      0
   251	      4      0   c011      2      1     13      0      1      0     11   dc1b
   252	     11      0     18      1      0     11      0bash-4.4$ echo "=================================================="
==================================================
bash-4.4$ java SYSTEM /home/opsys/SPR18/tb+err
bash-4.4$ cat -n Execution_profile.txt | head -40
     1	
     2	
     3	
     4	
     5	JOB ID : 3  (HEX)
     6	Termination type : ABNORMAL : ERROR_HANDLER: Conflict between size of Program words specified and no of program items given in the program section
     7	INPUT SEGMENT DATA FOR JOB 3 (HEX) : 
     8	OUTPUT SEGMENT DATA FOR JOB 3(BIN) : 
     9	CLOCK              : 0  (HEX)0
    10	ARRIVAL TIME       : 0 (DEC)
    11	DEPARTURE TIME       : 0 (DEC)
    12	JOB RUN TIME       : 0 (DEC)
    13	EXECUTION TIME     : 0 (DEC)
    14	INPUT/OUTPUT TIME  : 0  (DEC)
    15	NO OF PAGEFAULTS  : 0  (DEC)
    16	NO OF SEGMENT FAULTS  : 0  (DEC)
    17	SEGMENT FAULT TIME : 0  (DEC)
    18	PAGE FAULT TIME    : 0  (DEC)
    19	MEMORY UTILIZATION IN WORDS : RATIO  : 0/1 PERCENTAGE  : 0.00 %
    20	MEMORY UTILIZATION IN FRAMES : RATIO : 0/1 PERCENTAGE    : 0.00 %
    21	DISK UTILIZATION IN WORDS :   RATIO  : 3/64 PERCENTAGE : 4.69 %
    22	DISK UTILIZATION IN FRAMES :   RATIO : 3/64 PERCENTAGE  : 4.69 %
    23	MEMORY FRAGMENT SIZE : 0  (DEC)
    24	DISK FRAGMENT SIZE   : 0.0  (DEC)
    25	TURN AROUND TIME : 0  (DEC)
    26	
    27	-----------------------------------------
    28	
    29	 -----------------------SNAPSHOT---------------
    30	
    31	CONTENTS OF READY QUEUE         (DEC): 5,1,2,6,
    32	JOB ID CURRENTLY EXECUTING      (DEC): 4
    33	PMT  
    34	Page number  frame number
    35	    0      -     12
    36	    5      -     13
    37	    3      -     14
    38	
    39	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
    40	DEGREE OF MULTIPROGRAMMING      (DEC): 4
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -3000 | head -40
  7028	JOB ID CURRENTLY EXECUTING      (DEC): 78
  7029	PMT  
  7030	Page number  frame number
  7031	    6      -     5
  7032	    5      -     17
  7033	    4      -     24
  7034	    2      -     25
  7035	    3      -     26
  7036	    0      -     27
  7037	
  7038	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
  7039	DEGREE OF MULTIPROGRAMMING      (DEC): 4
  7040	MEMORY UTILIZATION              (DEC): 75.78%
  7041	DISK UTILIZATION                (DEC): 9.72%
  7042	----------------------------------------------
  7043	
  7044	
  7045	
  7046	
  7047	JOB ID : 78  (HEX)
  7048	INPUT SEGMENT DATA FOR JOB 78 (HEX) : 000A,0003,
  7049	OUTPUT SEGMENT DATA FOR JOB 78(BIN) : 0000000000001010,0000000000000011,0000001111101000,
  7050	CLOCK              : cc5e  (HEX)52318
  7051	ARRIVAL TIME       : 49939 (DEC)
  7052	DEPARTURE TIME       : 0 (DEC)
  7053	JOB RUN TIME       : 369 (DEC)
  7054	EXECUTION TIME     : 144 (DEC)
  7055	INPUT/OUTPUT TIME  : 75  (DEC)
  7056	NO OF PAGEFAULTS  : 7  (DEC)
  7057	NO OF SEGMENT FAULTS  : 2  (DEC)
  7058	SEGMENT FAULT TIME : 10  (DEC)
  7059	PAGE FAULT TIME    : 140  (DEC)
  7060	MEMORY UTILIZATION IN WORDS : RATIO  : 37/256 PERCENTAGE  : 14.45 %
  7061	MEMORY UTILIZATION IN FRAMES : RATIO : 3/16 PERCENTAGE    : 18.75 %
  7062	DISK UTILIZATION IN WORDS :   RATIO  : 45/2048 PERCENTAGE : 2.20 %
  7063	DISK UTILIZATION IN FRAMES :   RATIO : 7/256 PERCENTAGE  : 2.73 %
  7064	MEMORY FRAGMENT SIZE : 11  (DEC)
  7065	DISK FRAGMENT SIZE   : 3.6666666666666665  (DEC)
  7066	TURN AROUND TIME : 49864  (DEC)
  7067	
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -1400 | head -40
  8628	PMT  
  8629	Page number  frame number
  8630	    0      -     0
  8631	    5      -     1
  8632	    3      -     2
  8633	    2      -     3
  8634	    4      -     4
  8635	
  8636	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
  8637	DEGREE OF MULTIPROGRAMMING      (DEC): 4
  8638	MEMORY UTILIZATION              (DEC): 79.30%
  8639	DISK UTILIZATION                (DEC): 9.77%
  8640	----------------------------------------------
  8641	
  8642	-----------------------------------------
  8643	
  8644	 -----------------------SNAPSHOT---------------
  8645	
  8646	CONTENTS OF READY QUEUE         (DEC): 54,100,99,102,
  8647	JOB ID CURRENTLY EXECUTING      (DEC): 101
  8648	PMT  
  8649	Page number  frame number
  8650	    0      -     17
  8651	    3      -     18
  8652	    2      -     19
  8653	    1      -     20
  8654	    4      -     24
  8655	
  8656	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
  8657	DEGREE OF MULTIPROGRAMMING      (DEC): 4
  8658	MEMORY UTILIZATION              (DEC): 80.08%
  8659	DISK UTILIZATION                (DEC): 9.77%
  8660	----------------------------------------------
  8661	
  8662	-----------------------------------------
  8663	
  8664	 -----------------------SNAPSHOT---------------
  8665	
  8666	CONTENTS OF READY QUEUE         (DEC): 54,99,100,
  8667	JOB ID CURRENTLY EXECUTING      (DEC): 101
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -600 | head -40
  9428	 -----------------------SNAPSHOT---------------
  9429	
  9430	CONTENTS OF READY QUEUE         (DEC): 104,105,54,
  9431	JOB ID CURRENTLY EXECUTING      (DEC): 106
  9432	PMT  
  9433	Page number  frame number
  9434	    0      -     22
  9435	    3      -     23
  9436	    2      -     26
  9437	    1      -     27
  9438	    4      -     28
  9439	
  9440	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
  9441	DEGREE OF MULTIPROGRAMMING      (DEC): 3
  9442	MEMORY UTILIZATION              (DEC): 66.41%
  9443	DISK UTILIZATION                (DEC): 10.06%
  9444	----------------------------------------------
  9445	
  9446	-----------------------------------------
  9447	
  9448	 -----------------------SNAPSHOT---------------
  9449	
  9450	CONTENTS OF READY QUEUE         (DEC): 104,105,54,
  9451	JOB ID CURRENTLY EXECUTING      (DEC): 106
  9452	PMT  
  9453	Page number  frame number
  9454	    0      -     22
  9455	    3      -     23
  9456	    2      -     26
  9457	    1      -     27
  9458	    4      -     28
  9459	
  9460	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
  9461	DEGREE OF MULTIPROGRAMMING      (DEC): 3
  9462	MEMORY UTILIZATION              (DEC): 66.80%
  9463	DISK UTILIZATION                (DEC): 10.06%
  9464	----------------------------------------------
  9465	
  9466	-----------------------------------------
  9467	
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -200 | head -40
  9828	DISK UTILIZATION IN FRAMES :   RATIO : 3/64 PERCENTAGE  : 4.69 %
  9829	MEMORY FRAGMENT SIZE : 0  (DEC)
  9830	DISK FRAGMENT SIZE   : 4.666666666666667  (DEC)
  9831	TURN AROUND TIME : 41975  (DEC)
  9832	
  9833	-----------------------------------------
  9834	
  9835	 -----------------------SNAPSHOT---------------
  9836	
  9837	CONTENTS OF READY QUEUE         (DEC):  NO ELEMENT
  9838	JOB ID CURRENTLY EXECUTING      (DEC): 107
  9839	PMT  
  9840	Page number  frame number
  9841	    9      -     12
  9842	    4      -     13
  9843	    0      -     14
  9844	    1      -     15
  9845	    2      -     16
  9846	    3      -     17
  9847	
  9848	CONTENTS OF BLOCKED QUEUE       (DEC):  NO ELEMENT
  9849	DEGREE OF MULTIPROGRAMMING      (DEC): 0
  9850	MEMORY UTILIZATION              (DEC): 18.75%
  9851	DISK UTILIZATION                (DEC): 4.54%
  9852	----------------------------------------------
  9853	
  9854	-----------------------------------------
  9855	
  9856	 -----------------------SNAPSHOT---------------
  9857	
  9858	CONTENTS OF READY QUEUE         (DEC):  NO ELEMENT
  9859	JOB ID CURRENTLY EXECUTING      (DEC): 107
  9860	PMT  
  9861	Page number  frame number
  9862	    3      -     12
  9863	    8      -     13
  9864	    0      -     14
  9865	    1      -     15
  9866	    5      -     16
  9867	    2      -     17
bash-4.4$ ls
CPU.class   DISK.java		 Execution_profile.txt	Hextoany.class	LOADER.class  MEMORY.java	    OUTPUTSPOOLING.java  PMT.class  report.txt	  tracefile_1_26.txt  tracefile_1_4.txt   tracefile_1_81.txt
CPU.java    ERROR_HANDLER.class  FAULT_HANDLER.class	Hextoany.java	LOADER.java   output		    PCB.class		 PMT.java   SYSTEM.class  tracefile_1_34.txt  tracefile_1_50.txt  tracefile_1_85.txt
DISK.class  ERROR_HANDLER.java	 FAULT_HANDLER.java	input_phase2	MEMORY.class  OUTPUTSPOOLING.class  PCB.java		 report     SYSTEM.java   tracefile_1_37.txt  tracefile_1_68.txt  typescript
bash-4.4$ cat -n Execution_profile.txt | tail -40
  9988	CPU SHOTS 
  9989	---MINIMUM       (DEC): 3 
  9990	---MAXIMUM       (DEC): 500 
  9991	---AVERAGE       (DEC): 370.61 
  9992	
  9993	I/0 REQUESTS 
  9994	---MINIMUM       (DEC): 2 
  9995	---MAXIMUM       (DEC): 22 
  9996	---AVERAGE       (DEC): 25.66 
  9997	----------------------------------------------------------
  9998	-----------------------------------------------------------
  9999	
 10000	JOBS THAT TERMINATED NORMALLY (DEC): 84 
 10001	
 10002	
 10003	JOBS THAT TERMINATED ABNORMALLY (DEC): 23 
 10004	
 10005	
 10006	TIME LOST DUE TO ABNORMAL TERMINATION OF JOBS :24105 
 10007	
 10008	
 10009	TIME LOST DUE SUSPECTED INFINITE JOBS (DEC):22825 (DEC)
 10010	
 10011	
 10012	ID'S OF JOBS SUSPECTED INFINITE (DEC):
 10013	10,10,
 10014	
 10015	MEAN TURN AROUND TIME OF JOBS THAT TERMINATED NORMALLY (DEC): 2383.58 
 10016	
 10017	
 10018	MEAN WAITING TIME OF JOBS THAT TERMINATED NORMALLY (DEC): 2114.44 
 10019	
 10020	
 10021	MEAN NUMBER OF PAGEFAULTS (DEC): 8.00 
 10022	
 10023	
 10024	MEAN MEMORY UTILIZATION OVER ALL SAMPLING INTERVALS (DEC): 74.00% 
 10025	
 10026	
 10027	MEAN DISK UTILIZATION OVER ALL SAMPLING INTERVALS (DEC): 11.00 %
bash-4.4$ cat -n report.txt
     1	SOFTWARE ENGINEERING ISSUES
     2	
     3	1. GENERAL APPROACH TO THE PROBLEM:
     4	
     5	I felt comfortable with the project after completing my phase 2. In this phase it took me lot of time to understand the
     6	program manager and its functionality. I have approached the problem by breaking it down the phase to several modules.
     7	This phase nedds lots to be modified than the other phase. we have to introduce a program manager which schedules the jobs
     8	that are in the system. I started my coding with designing the program manager first then pushing all the job related variables
     9	to PCB, thereby allowing every process to have its own share of variables. It took me five days to code this phase.
    10	Solving tb+error part was a bit hard and consumed lot of time.
    11	
    12	2. LIST OF UTILITIES USED.
    13	
    14	I have used IntelliJ IDE to code and have used java programming language.
    15	
    16	3. BULK COMPLEXITIES OF SIMULATED PROGRAM:
    17	
    18	 (1). Total no of lines of code : 2,304
    19	     (a). Declarations : 256
    20	     (b). Comment lines: 220
    21	     (c). Actual code  : 1828
    22	 (2). Number of decisions : 92
    23	 (3). Methods : 19
    24	 (4). No of classes : 11
    25	
    26	 a. MODULE : SYSTEM
    27	     (1). Declarations: 25
    28	     (2). comment lines 20
    29	     (3). No of methods 2
    30	     (4). Total line of code : 747
    31	  b. MODULE : CPU
    32	      (1). Declarations : 19
    33	      (2). comment lines: 6
    34	      (3).Executables    : 500
    35	      (4). Methods : 6
    36	      (5). Total line of code : 820
    37	   c. MODULE : DISK
    38	      (1). Declarations : 5
    39	      (2). comments : 5
    40	      (3). Methods : 1
    41	      (4). Total line of code : 31
    42	    d. MODULE : LOADER
    43	       (1). Declarations : 7
    44	        (2). comments : 4
    45	        (3). Methods : 1
    46	        (4). Total line of code : 80
    47	     e. MODULE : MEMORY
    48	         (1). Declarations : 6
    49	         (2). comments : 5
    50	          3). Methods : 1
    51	         (4). Total line of code : 63
    52	     f. MODULE : OUTPU
    53	     TSPOOLING
    54	         (1). Declarations : 8
    55	         (2). comments : 7
    56	          3). Methods : 3
    57	         (4). Total line of code : 339
    58	     g. MODULE : FAULTHANDLER
    59	         (1). Declarations : 11
    60	         (2). comments : 14
    61	          3). Methods : 2
    62	         (4). Total line of code : 194
    63	     h. MODULE : PCB
    64	         (1). Declarations : 11
    65	         (2). comments :18
    66	          3). Methods : 0
    67	         (4). Total line of code : 78
    68	
    69	
    70	The operating system I simulated is portable to different architectures and operating systems as
    71	I chose Java which is machine independent. I would highly recommend JAVA programming for this assignment as it an
    72	object oriented programming language which has more benefits like modularity as it allows to add more functionality
    73	in future as discussed above.
    74	
bash-4.4$ exit
exit

Script done on 2018-05-02 11:07:33-0500
